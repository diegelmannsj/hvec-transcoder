#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete
import re
import shutil
from tqdm import tqdm
import grp # Added for group name resolution
from typing import Dict, Any # Added for type hinting

# --- Version History ---
__version__ = "8.0"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v8.0    feat(normalize): Add protected codec list
        
        - Added a "hands-off" list of protected audio codecs:
          'dts', 'truehd', 'eac3', 'ac3', 'pcm'.
        - When -N is used, the script now checks the source
          audio codec first.
        - If the codec is on the protected list, normalization
          is skipped entirely, and the audio track is copied.
        - The "smart" normalization logic and downmix-prompt
          will now only apply to non-protected codecs
          (like aac, mp3, vorbis, etc.).

v7.9    feat(normalize): Add prompt before downmixing audio
        feat(normalize): Use smart audio codec selection

        - The -N (normalize) logic now first checks the input
          audio stream.
        - If normalization would result in a channel downmix
          (e.g., 6.1 -> 5.1), it now prompts the user [N/y]
          before continuing. If 'No', audio is copied.
        - Implemented "smart" audio encoding for normalization:
          - 2.0 (stereo) sources are encoded to VBR AAC 2.0.
          - 5.1/6.1/7.1 (surround) sources are encoded to
            AC3 5.1 @ 640k to preserve channels.

v7.8    feat(normalize): Read data from ,audit_loudness log
v7.7    fix(remux): Apply -fflags +genpts to all .avi operations
v7.6    fix(ffmpeg): Correct ffmpeg syntax for -vf filter
v7.5    fix(ffmpeg): Add hwupload filter for software-decoded .avi
v7.4    feat(normalize): Print audio stats & use VBR for audio
v7.3    feat(normalize): Add .NORM suffix and update summary
v7.2.2  fix(ffmpeg): Add -nostdin flag to disable interactive mode
v7.2.1  fix(typo): Corrected 'add_ar_argument' to 'add_argument'
v7.2    fix(logic): Allow --normalize and --remux to work together
v7.1    feat(audio): Add -N/--normalize flag for 2-pass loudnorm
v7.0    refactor(chapters): Use mkvpropedit for chapter embedding
        ...
"""
# --- MODIFICATION END ---

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')
PROTECTED_AUDIO_CODECS = ('dts', 'truehd', 'eac3', 'ac3', 'pcm') # (v8.0)

# --- Helper Functions ---
def get_total_frames(file_path):
    """Gets total frames quickly using mediainfo (preferred) or falls back."""
    if shutil.which('mediainfo'):
        cmd = ['mediainfo', '--Inform=Video;%FrameCount%', file_path]
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            return int(result.stdout.strip())
        except (subprocess.CalledProcessError, ValueError, FileNotFoundError):
            pass
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=duration,avg_frame_rate', '-of', 'json', file_path]
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        data = json.loads(result.stdout)['streams'][0]
        if 'duration' not in data or 'avg_frame_rate' not in data: return None
        duration, fr_str = float(data['duration']), data['avg_frame_rate']
        if '/' in fr_str:
            n, d = map(int, fr_str.split('/')); frame_rate = n / d if d != 0 else 0
        else: frame_rate = float(fr_str)
        if duration <= 0 or frame_rate <= 0: return None
        return int(duration * frame_rate)
    except Exception: return None

def get_stream_info(file_path):
    """Uses ffprobe to get structured information about all streams in a file."""
    ffprobe_cmd = ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', file_path]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return json.loads(result.stdout).get('streams', [])
    except Exception:
        print(f"Error: Could not get stream information from '{file_path}'.", file=sys.stderr); return None

def plan_stream_selection(streams):
    streams_to_keep, streams_to_remove = [], []
    for s in streams:
        keep = False; stype = s.get('codec_type'); tags = s.get('tags', {}); lang = tags.get('language', 'und').lower(); title = s.get('title', '').lower()
        if stype == 'video' or (stype == 'audio' and (lang == 'eng' or 'commentary' in title or 'director' in title)) or (stype == 'subtitle' and lang == 'eng'): keep = True
        if keep: streams_to_keep.append(s)
        else: streams_to_remove.append(s)
    return streams_to_keep, streams_to_remove

def display_and_confirm_plan(s_keep, s_rem):
    print("\n--- Stream Selection Plan ---\nKEPT:"); [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_keep]
    print("\nREMOVED:"); [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_rem]
    try: return input("Proceed? [y/N]: ").lower().strip() == 'y'
    except KeyboardInterrupt: return False

def format_size(size_bytes):
    """Converts a size in bytes to a human-readable string using binary prefixes."""
    if size_bytes is None or not isinstance(size_bytes, (int, float)) or size_bytes < 0: return "N/A"
    if size_bytes == 0: return "0 B"
    size_name = ("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB")
    try:
        i = int(math.floor(math.log(size_bytes, 1024))); i = min(i, len(size_name) - 1)
        p = math.pow(1024, i); s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"
    except (ValueError, TypeError): return "N/A"

def print_size_summary(original_size_bytes, new_size_bytes, audio_normalized=False):
    """Prints a formatted summary of the file size change."""
    print("\n--- File Size Summary ---")
    original_size_str = format_size(original_size_bytes); new_size_str = format_size(new_size_bytes)
    print(f"Original:   {original_size_str}"); print(f"New:         {new_size_str}")
    if original_size_bytes is not None and new_size_bytes is not None and original_size_bytes > 0:
        difference_bytes = new_size_bytes - original_size_bytes; percentage_change = (difference_bytes / original_size_bytes) * 100
        change_type = "increase" if difference_bytes >= 0 else "decrease"; difference_str = format_size(abs(difference_bytes))
        print(f"Difference: {difference_str} ({abs(percentage_change):.2f}% {change_type})")
    else: print("Difference: N/A")
    
    if audio_normalized:
        print("Audio:      Normalized (EBU R128)")
    
    print("-------------------------")

def find_video_files(p, r):
    vids = [];
    if r: [vids.extend([os.path.join(root, f) for f in files if f.lower().endswith(VIDEO_EXTENSIONS)]) for root, _, files in os.walk(p)]
    else: vids.extend([os.path.join(p, f) for f in os.listdir(p) if f.lower().endswith(VIDEO_EXTENSIONS)])
    return vids

def is_hevc(f):
    if not os.path.exists(f): return False
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=codec_name', '-of', 'default=noprint_wrappers=1:nokey=1', f]
    try: return 'hevc' in subprocess.run(cmd, check=True, capture_output=True, text=True).stdout.lower()
    except Exception: return False

def print_ffmpeg_command(cmd):
    """Prints the FFmpeg command for dry-run mode."""
    print("\nExecuting FFmpeg command (Dry Run):")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))

# --- NEW (v7.9): Helper to get audio info before analysis ---
def get_audio_info(file_path: str) -> Dict[str, Any] or None:
    """Probes the first audio stream for codec and channels."""
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'a:0',
           '-show_entries', 'stream=codec_name,channels',
           '-of', 'json', file_path]
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True, encoding='utf-8')
        data = json.loads(result.stdout)['streams'][0]
        if 'codec_name' not in data or 'channels' not in data:
            print("Warning: Could not get audio channels/codec from ffprobe.", file=sys.stderr)
            return None
        return {'codec': data['codec_name'], 'channels': int(data['channels'])}
    except Exception as e:
        print(f"Warning: Could not probe audio stream info: {e}", file=sys.stderr)
        return None
# --- END NEW (v7.9) ---

def run_loudnorm_analysis(input_file: str) -> Dict[str, float] or None:
    """
    Runs FFmpeg Pass 1 to analyze audio loudness and returns the parsed JSON data.
    """
    cmd = [
        'ffmpeg', '-nostdin', '-i', input_file, # Added -nostdin
        '-map', '0:a:0',  # Analyze the first audio stream
        '-af', 'loudnorm=print_format=json',
        '-f', 'null', '-'
    ]
    try:
        # ffmpeg writes all info, including the JSON, to stderr.
        result = subprocess.run(cmd, check=False, capture_output=True, text=True, encoding='utf-8')
        stderr_output = result.stderr
        
        if not stderr_output:
            print("Error: No output from ffmpeg analysis.", file=sys.stderr)
            return None

        # Find the JSON block. It's the last { ... } block in the output.
        start_index = stderr_output.rfind('{')
        end_index = stderr_output.rfind('}')
        
        if start_index == -1 or end_index == -1 or end_index < start_index:
            print(f"Error: Could not find JSON block in ffmpeg analysis output.", file=sys.stderr)
            print(f"--- FFmpeg Stderr ---\n{stderr_output}\n---------------------", file=sys.stderr)
            return None
            
        json_text = stderr_output[start_index:end_index+1]
        data = json.loads(json_text)
        
        # Return the 4 required values in our standard dictionary format
        loudness_data = {
            'i': float(data['input_i']),
            'tp': float(data['input_tp']),
            'lra': float(data['input_lra']),
            'thresh': float(data['input_thresh'])
        }
        return loudness_data
        
    except (subprocess.CalledProcessError, FileNotFoundError, json.JSONDecodeError) as e:
        print(f"\nError during audio analysis: {e}", file=sys.stderr)
        if 'stderr_output' in locals():
            print(f"--- FFmpeg Stderr ---\n{stderr_output}\n---------------------", file=sys.stderr)
        return None
    except Exception as e:
        print(f"\nAn unexpected error occurred during audio analysis: {e}", file=sys.stderr)
        return None

def embed_chapters_mkvpropedit(chapter_file, output_mkv):
    """Embeds chapters into an existing MKV file using mkvpropedit."""
    if not shutil.which('mkvpropedit'):
        print("\nError: 'mkvpropedit' command not found. Please install MKVToolNix.", file=sys.stderr)
        return False
    if not os.path.exists(chapter_file):
        print(f"\nError: Chapter file not found at '{chapter_file}'.", file=sys.stderr)
        return False
    if not os.path.exists(output_mkv):
        print(f"\nError: Output MKV file '{output_mkv}' not found for chapter embedding.", file=sys.stderr)
        return False

    mkvpropedit_cmd = ['mkvpropedit', output_mkv, '--chapters', chapter_file]
    print("\nExecuting mkvpropedit command:")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in mkvpropedit_cmd))

    try:
        # Capture output to check for errors/warnings
        result = subprocess.run(mkvpropedit_cmd, check=True, capture_output=True, text=True)
        # mkvpropedit often prints progress or confirmations to stdout/stderr even on success
        if result.stdout: print("mkvpropedit output:", result.stdout)
        if result.stderr: print("mkvpropedit errors/warnings:", result.stderr)
        print(f"Successfully embedded chapters into '{os.path.basename(output_mkv)}'.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"\n--- mkvpropedit Error ---", file=sys.stderr)
        print(f"Command failed with exit code {e.returncode}", file=sys.stderr)
        if e.stdout: print("stdout:", e.stdout, file=sys.stderr)
        if e.stderr: print("stderr:", e.stderr, file=sys.stderr)
        print(f"-------------------------", file=sys.stderr)
        return False
    except Exception as e:
        print(f"\nAn unexpected error occurred running mkvpropedit: {e}", file=sys.stderr)
        return False

def run_ffmpeg_command(cmd, source_file, delete_source, audio_normalized=False, total_frames=None, permissions=None, chapter_file_to_embed=None):
    """Executes FFmpeg, shows progress, verifies output, and optionally embeds chapters."""
    print("\nExecuting FFmpeg command:")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))
    output_file = cmd[-1]
    original_size_bytes = os.path.getsize(source_file) if os.path.exists(source_file) else None
    
    # --- FFmpeg Execution ---
    ffmpeg_success = False
    try:
        if "-progress" not in cmd:
            subprocess.run(cmd, check=True)
        else:
            if total_frames is None: print("\nWarning: Could not get total frames. Progress bar indeterminate.")
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8')
            with tqdm(total=total_frames, unit='frame', dynamic_ncols=True, desc="FFmpeg") as pbar:
                for line in process.stdout:
                    if line.strip().startswith("frame="):
                        current_frame = int(line.strip().split("=")[1]); pbar.update(max(0, current_frame - pbar.n))
            stderr_output = process.stderr.read(); process.wait()
            if process.returncode != 0: raise subprocess.CalledProcessError(process.returncode, cmd, stderr=stderr_output)
        ffmpeg_success = True
    except (subprocess.CalledProcessError, FileNotFoundError, KeyboardInterrupt) as e:
        if isinstance(e, subprocess.CalledProcessError): print(f"\n--- FFmpeg Error ---\n{e.stderr}\n--------------------", file=sys.stderr)
        elif isinstance(e, FileNotFoundError): print("\nError: Required command not found (ffmpeg/stdbuf).", file=sys.stderr)
        else: print("\nCancelled.", file=sys.stderr)
        if 'process' in locals(): process.terminate()
        sys.exit(1) # Exit immediately on FFmpeg failure

    # --- Post-FFmpeg Verification ---
    if not ffmpeg_success or not os.path.exists(output_file):
        print(f"\nError: FFmpeg failed or output file '{output_file}' not created.", file=sys.stderr); sys.exit(1)
    try:
        new_size_bytes = os.path.getsize(output_file)
        subprocess.run(['ffprobe', '-v', 'error', output_file], check=True, capture_output=True)
    except Exception:
        print(f"\nError: Output file '{output_file}' appears invalid after FFmpeg.", file=sys.stderr); sys.exit(1)
    
    print(f"\nSuccessfully created and verified FFmpeg output '{output_file}'.")
    
    # --- Chapter Embedding (NEW STEP) ---
    chapters_embedded_successfully = True # Assume success if not requested
    if chapter_file_to_embed:
        chapters_embedded_successfully = embed_chapters_mkvpropedit(chapter_file_to_embed, output_file)
        if not chapters_embedded_successfully:
            print(f"\nError: Failed to embed chapters using mkvpropedit. Output file '{output_file}' may be incomplete.", file=sys.stderr)
            # Decide if you want to exit here or continue. For now, we continue but warn.
            # sys.exit(1)
    # --- END Chapter Embedding ---

    # --- Permissions ---
    if permissions:
        try:
            os.chown(output_file, permissions['uid'], permissions['gid']); os.chmod(output_file, permissions['mode'])
            print(f"Info: Applied permissions to '{os.path.basename(output_file)}'.")
        except OSError as e: print(f"\nWarning: Could not set permissions. Reason: {e}", file=sys.stderr)

    print_size_summary(original_size_bytes, new_size_bytes, audio_normalized=audio_normalized)
    
    # --- Delete Source ---
    # Only delete if BOTH FFmpeg AND chapter embedding (if requested) were successful
    if delete_source and ffmpeg_success and chapters_embedded_successfully:
        print(f"\nInfo: --delete flag set. Deleting source file...")
        try:
            os.remove(source_file); print(f"Successfully deleted: {source_file}")
        except OSError as e: print(f"\nError: Could not delete source '{source_file}'. Reason: {e}", file=sys.stderr)
    elif delete_source:
         print(f"\nWarning: --delete flag ignored because chapter embedding failed.")

# --- NEW HELPER FUNCTION (v7.8) ---
def load_loudness_db(log_file: str) -> Dict[str, Dict[str, float]]:
    """
    Reads a pipe-delimited loudness audit log file and returns a
    dictionary mapping file paths to their normalization data.
    """
    db = {}
    if not os.path.exists(log_file):
        print(f"Warning: Loudness log not found at '{log_file}'. Will run analysis.", file=sys.stderr)
        return db

    print(f"Info: Loading loudness database from '{os.path.basename(log_file)}'...")
    try:
        with open(log_file, 'r', encoding='utf-8') as f:
            for line in f:
                if line.startswith("Timestamp|Status"):
                    continue
                
                try:
                    parts = line.strip().split('|')
                    # v1.8 log has 11 columns (10 pipes)
                    if len(parts) >= 10 and parts[1] == 'SUCCESS':
                        file_path = parts[2].strip()
                        # Keys must match what run_loudnorm_analysis returns
                        data = {
                            'i': float(parts[5]),
                            'tp': float(parts[7]),
                            'lra': float(parts[8]),
                            'thresh': float(parts[9])
                        }
                        db[file_path] = data
                except (IndexError, ValueError):
                    pass # Ignore malformed or non-SUCCESS lines
    except Exception as e:
        print(f"Error: Could not read loudness log '{log_file}': {e}", file=sys.stderr)
    
    print(f"Info: Loaded {len(db)} pre-analyzed entries.")
    return db
# --- END NEW HELPER FUNCTION ---


# --- Main Logic ---
def main():
    print(f",hvec v{__version__}") # Print current version first

    # --- Argument Parser ---
    parser = argparse.ArgumentParser(description="A tool to transcode or remux files using Intel VAAPI.", formatter_class=argparse.RawTextHelpFormatter, epilog="Examples:\n  ,hvec -i \"My Movie.mkv\" -k\n  ,hvec -i /videos/ -D -k -R\n  ,hvec -i movie.mp4 -r -C chapters.txt\n  ,hvec -i movie.mkv -N /path/to/loudness_audit.log")
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    parser.add_argument("-o", "--output", help="Output MKV file (single file mode only).")
    parser.add_argument("-k", "--filter-streams", action="store_true", help="Interactively filter streams (single file mode only).")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete original file after success.")
    parser.add_argument("--out-dir", help="Output directory for batch processing.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process subdirectories.")
    parser.add_argument("-C", "--chapters", help="External chapter file (TXT/OGM or XML) to embed (requires MKVToolNix).")
    parser.add_argument("-s", "--subs", nargs='+', help="External subtitle files to embed (single file mode only).")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force HEVC output (overrides --remux).")
    
    # --- MODIFIED: -N now optionally takes a value (v7.8) ---
    parser.add_argument(
        "-N", "--normalize", 
        nargs='?', 
        const=True, 
        default=None, 
        help="Normalize audio to EBU R128 (-23 LUFS). \n"
             "Optionally provide a path to a loudness_audit.log file \n"
             "to skip analysis and use pre-scanned values."
    )
    # --- END MODIFIED ---
    
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set VAAPI quality (1-51).")
    parser.add_argument("-p", "--preset", type=str, default='medium', choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'], help="Set encoding preset.")
    parser.add_argument("--acodec", help="Re-encode audio codec (e.g., 'aac', 'ac3'). Default: 'copy'.")
    parser.add_argument("--abitrate", help="Set audio bitrate (e.g., '192k', '384k').")
    parser.add_argument("--skip-hevc", action="store_true", help="Skip files that are already HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print commands without executing.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux (instead of transcode).")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress FFmpeg output.")
    parser.add_argument("-v", "--version", action="store_true", help="Show version history and exit.")
    
    argcomplete.autocomplete(parser); args = parser.parse_args()
    
    if args.version: print(VERSION_HISTORY); sys.exit(0) # Handle --version flag

    if not os.path.exists(args.input): print(f"Error: Input not found: {args.input}", file=sys.stderr); sys.exit(1)
    
    # --- MODIFIED: Load Loudness DB (v7.8) ---
    loudness_db = {}
    is_normalize_enabled = args.normalize is not None
    
    if isinstance(args.normalize, str):
        # This means a log file path was provided, e.g., -N file.log
        loudness_db = load_loudness_db(args.normalize)
    # --- END MODIFIED ---
    
    # --- File Processing Loop ---
    files_to_process = find_video_files(args.input, args.recursive) if os.path.isdir(args.input) else [args.input]
    if not files_to_process: print("No video files found to process."); sys.exit(0)

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        
        # --- Chapter File Handling ---
        # Store chapter file path separately, disable for batch unless explicitly handled later
        chapter_file_for_this_run = args.chapters
        if chapter_file_for_this_run and len(files_to_process) > 1:
            print("Info: --chapters flag is ignored in batch/directory mode for now.")
            chapter_file_for_this_run = None # Disable chapters for batch mode
        if chapter_file_for_this_run and not os.path.exists(chapter_file_for_this_run):
             print(f"Warning: Chapter file '{chapter_file_for_this_run}' not found. Skipping chapter embedding.")
             chapter_file_for_this_run = None

        # --- Permissions ---
        permissions_to_apply = None
        try:
            stat_info = os.stat(input_file); input_gid = stat_info.st_gid; input_group_name = grp.getgrgid(input_gid).gr_name
            target_gid = input_gid
            if input_group_name != 'jellyfin':
                try:
                    jellyfin_gid = grp.getgrnam('jellyfin').gr_gid
                    response = input(f"Warning: Source group is '{input_group_name}'. Change output to 'jellyfin'? [Y/n]: ").lower().strip()
                    if response in ('y', 'yes', ''): target_gid = jellyfin_gid; print("Info: Output group set to 'jellyfin'.")
                except KeyError: print("Info: 'jellyfin' group not found. Preserving original.")
                except (KeyboardInterrupt, EOFError): print("\nCancelled."); sys.exit(1)
            permissions_to_apply = {'uid': stat_info.st_uid, 'gid': target_gid, 'mode': stat_info.st_mode}
        except (OSError, KeyError) as e: print(f"Warning: Could not read source permissions. Reason: {e}", file=sys.stderr)

        # --- Skip HEVC Check ---
        if args.skip_hevc and is_hevc(input_file): print("Already HEVC. Skipping."); continue

        # --- Output Filename Generation ---
        is_remux_op = args.remux and not args.hvec # <--- Moved this line up
        
        def generate_output_filename(base, is_remux, has_chapters, is_normalized):
            sanitized = re.sub(r'[\(\)\[\]]', '', base).replace(' ', '.').replace('_', '.') # Cleaner regex
            suffix = ".REMUX" if is_remux else ".CONV"
            chapter_suffix = ".CHAPTERS" if has_chapters else ""
            norm_suffix = ".NORM" if is_normalized else "" # <--- Use our new flag
            # Ensure suffix isn't duplicated, handle case where base already ends with it
            base_no_suffix = sanitized.replace(suffix, '') if sanitized.endswith(suffix) else sanitized
            return f"{base_no_suffix}{suffix}{norm_suffix}{chapter_suffix}.mkv"

        if args.output and len(files_to_process) == 1: output_file = args.output
        else:
            base, _ = os.path.splitext(os.path.basename(input_file));
            # Check for suffixes
            has_chapters_flag = chapter_file_for_this_run is not None
            has_normalized_flag = is_normalize_enabled # <--- Use our new flag
            new_filename = generate_output_filename(base, is_remux_op, has_chapters_flag, has_normalized_flag)
            
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input if os.path.isdir(args.input) else os.path.dirname(args.input))
                output_dir = os.path.join(args.out_dir, relative_path); os.makedirs(output_dir, exist_ok=True)
                output_file = os.path.join(output_dir, new_filename)
            else: output_file = os.path.join(os.path.dirname(input_file), new_filename)
        
        # Prevent source overwrite
        if os.path.abspath(output_file) == os.path.abspath(input_file):
            base, ext = os.path.splitext(output_file); output_file = f"{base}.COPY{ext}"
            print(f"Info: Output name identical to input. Using '{os.path.basename(output_file)}'")
                    
        # Overwrite check
        if os.path.exists(output_file) and not args.dry_run:
            try:
                if input(f"Output '{os.path.basename(output_file)}' exists. Overwrite? [y/N]: ").lower().strip() != 'y': print("Skipping."); continue
            except KeyboardInterrupt: print("\nCancelled."); sys.exit(1)
        
        # --- FFmpeg Command Construction ---
        total_frames = get_total_frames(input_file) if not (is_remux_op or args.quiet or args.dry_run) else None
        
        ffmpeg_cmd = ['ffmpeg', '-y', '-nostdin']
        
        # Progress/Verbosity
        use_progress_bar = total_frames is not None and not (is_remux_op or args.quiet or args.dry_run)
        if use_progress_bar:
            if sys.platform != "win32": ffmpeg_cmd = ['stdbuf', '-o0'] + ffmpeg_cmd
            ffmpeg_cmd.extend(['-progress', '-', '-nostats'])
        elif args.quiet: ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        else: ffmpeg_cmd.extend(['-v', 'error', '-stats'])
        
        # --- HWACCEL & .avi FIX (v7.7) ---
        is_avi = input_file.lower().endswith('.avi')
        is_transcode = not is_remux_op
        
        if is_avi:
            # .avi files almost always need this to fix broken timestamps,
            # for both remuxing and transcoding.
            ffmpeg_cmd.extend(['-fflags', '+genpts'])

        if is_transcode and not is_avi:
            # Use hwaccel decode ONLY for non-avi transcodes
            ffmpeg_cmd.extend(['-hwaccel', 'vaapi', '-hwaccel_output_format', 'vaapi'])
        # --- END FIX ---
            
        # --- Input Files ---
        ffmpeg_cmd.extend(['-i', input_file]) # Main video input is always index 0 now
        
        # Add subtitle inputs if provided (single file mode only)
        subtitle_input_index = 1 # Starts after main video input
        if args.subs and len(files_to_process) == 1:
            valid_subs = []
            for sub_file in args.subs:
                if os.path.exists(sub_file):
                    ffmpeg_cmd.extend(['-i', sub_file])
                    valid_subs.append(sub_file)
                else: print(f"Warning: Subtitle file not found: {sub_file}")
            args.subs = valid_subs # Update args to only include valid subs found
        
        # --- Stream Mapping ---
        if args.filter_streams and len(files_to_process) == 1:
            all_streams = get_stream_info(input_file)
            if all_streams is None: continue
            s_keep, s_rem = plan_stream_selection(all_streams)
            if not display_and_confirm_plan(s_keep, s_rem): print("Skipping file."); continue
            for stream in s_keep: ffmpeg_cmd.extend(['-map', f"0:{stream['index']}"])
            args.subs = [] # Disable subtitle embedding if filtering

        elif args.subs: # Only map subs if -s was used and -k was not
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?'])
            for j in range(len(args.subs)):
                 ffmpeg_cmd.extend(['-map', f'{subtitle_input_index + j}:s:0', f'-metadata:s:s:{j}', 'language=eng'])
        
        else: # Default: Map all streams from main input
            ffmpeg_cmd.extend(['-map', '0']) # Map all streams from input 0

        # --- Codec Logic (Refactored for v8.0) ---
        audio_normalized = False # Define here
        run_normalization = is_normalize_enabled # Use a temp flag
        
        if is_normalize_enabled:
            if is_remux_op:
                print("Info: Normalizing audio while remuxing video.")
            
            # --- NEW (v8.0): Check for protected codecs ---
            audio_info = get_audio_info(input_file)
            
            if audio_info and audio_info['codec'] in PROTECTED_AUDIO_CODECS:
                print(f"Info: Skipping normalization for protected audio format ({audio_info['codec'].upper()}). Audio will be copied.")
                run_normalization = False # Skip the rest of the normalization logic
            # --- END NEW (v8.0) ---
            
            if run_normalization:
                # --- NEW (v7.9): Plan audio output and prompt for downmixing ---
                output_codec = "aac" # Default
                output_bitrate_args = ["-q:a:0", "4"] # Default (VBR)
                
                if audio_info:
                    source_codec = audio_info['codec']
                    source_channels = audio_info['channels']
                    output_channels = 2 # Default

                    if source_channels > 2: # 5.1, 6.1, 7.1
                        output_codec = "ac3"
                        output_channels = 6 # Preserve 5.1, downmix 6.1/7.1
                        output_bitrate_args = ["-b:a:0", "640k"]
                    else: # 1.0, 2.0
                        output_codec = "aac"
                        output_channels = 2 # Preserve 2.0, upmix 1.0
                        output_bitrate_args = ["-q:a:0", "4"]

                    # Now, check if we're downmixing and prompt
                    if source_channels > output_channels:
                        print(f"\nWarning: Source audio is {source_codec.upper()} {source_channels}.0 channels.")
                        print(f"         Normalization will DOWNMIX to {output_codec.upper()} {output_channels}.0 channels.")
                        try:
                            response = input("         Continue with normalization? [N/y]: ").lower().strip()
                            if response not in ('y', 'yes'):
                                run_normalization = False
                        except KeyboardInterrupt:
                            print("\nSkipping normalization.")
                            run_normalization = False

                    if not run_normalization:
                        print("Info: Skipping normalization, audio will be copied.")
                
                else:
                    print("Warning: Could not get audio info. Defaulting to AAC 2.0 normalization.")
                # --- END NEW (v7.9) ---

            if run_normalization:
                # --- MODIFIED: Loudness DB check (v7.8) ---
                # (This block only runs if run_normalization is still True)
                analysis_data = None
                abs_input_file = os.path.abspath(input_file)
                
                if abs_input_file in loudness_db:
                    analysis_data = loudness_db[abs_input_file]
                    print("Info: Using pre-analyzed loudness data from log.")
                else:
                    if isinstance(args.normalize, str):
                        print(f"Info: File not found in log, running live analysis...")
                    print("Running audio normalization analysis (Pass 1)...")
                    analysis_data = run_loudnorm_analysis(input_file)
                    if analysis_data:
                        print("Analysis complete.")
                # --- END MODIFIED ---
                
                if analysis_data:
                    try:
                        measured_i = analysis_data['i']
                        measured_tp = analysis_data['tp']
                        measured_lra = analysis_data['lra']
                        measured_thresh = analysis_data['thresh']
                        
                        # Print audio stats
                        print("Info: Audio analysis found:")
                        print(f"  - Input Loudness: {measured_i:.2f} LUFS")
                        print(f"  - Input True Peak: {measured_tp:.2f} dBTP")
                        
                        filter_string = f"loudnorm=I=-23:LRA=7:tp=-2:measured_I={measured_i}:measured_tp={measured_tp}:measured_LRA={measured_lra}:measured_thresh={measured_thresh}"
                        
                        # Apply normalization to first audio stream, copy others
                        # --- MODIFIED (v7.9): Use smart codec/bitrate ---
                        ffmpeg_cmd.extend(['-c:a', 'copy', '-c:a:0', output_codec] + output_bitrate_args + ['-af:a:0', filter_string])
                        
                        print(f"Info: Audio stream 0 will be normalized (to {output_codec.upper()}). Other audio streams copied.")
                        audio_normalized = True # Mark as complete
                    except KeyError:
                        print("Warning: Audio analysis data was incomplete. Falling back to default audio settings.", file=sys.stderr)
                else:
                    print("Warning: Audio normalization analysis failed. Falling back to default audio settings.", file=sys.stderr)
        
        if not audio_normalized:
            # This block now handles:
            # 1. Normalization was OFF
            # 2. Normalization was ON but codec was PROTECTED
            # 3. Normalization was ON but user said NO to downmix
            # 4. Normalization was ON but FAILED (e.g. analysis failed)
            
            if args.acodec:
                ffmpeg_cmd.extend(['-c:a', args.acodec])
                if args.abitrate: ffmpeg_cmd.extend(['-b:a', args.abitrate])
            else:
                ffmpeg_cmd.extend(['-c:a', 'copy'])
                
                # Print a helpful "copying" message if we haven't already
                if not is_normalize_enabled:
                    print("Info: Copying all audio streams.")
                elif not run_normalization:
                    # We already printed a "Skipping" message, so just pass
                    pass
                else:
                    # This means normalization was on, run_normalization was true,
                    # but it failed (audio_normalized=False)
                    print("Info: Copying all audio streams due to normalization failure.")


        # 3. SUBTITLE LOGIC
        # Always convert to srt for max compatibility (per v6.3 fix)
        ffmpeg_cmd.extend(['-c:s', 'srt'])
        
        # --- END Codec Logic ---

        ffmpeg_cmd.append(output_file) # Add output file path
        
        # --- Execute ---
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
            if chapter_file_for_this_run:
                 mkvpropedit_cmd = ['mkvpropedit', output_file, '--chapters', chapter_file_for_this_run]
                 print("\nMKVPropEdit command (Dry Run):")
                 print(' '.join(f'"{a}"' if ' ' in a else a for a in mkvpropedit_cmd))
        else:
            run_ffmpeg_command(
                ffmpeg_cmd,
                input_file,
                args.delete,
                audio_normalized=audio_normalized, # <--- MODIFIED
                total_frames=total_frames,
                permissions=permissions_to_apply,
                chapter_file_to_embed=chapter_file_for_this_run
            )

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()