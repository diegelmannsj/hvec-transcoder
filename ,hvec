#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete
import re
from tqdm import tqdm

# --- Version History ---
__version__ = "5.9"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v5.9: Added a tqdm progress bar with ETA for FFmpeg transcode operations.
      (Note: Requires 'pip install tqdm'). The bar is skipped for remuxing
      or when --quiet is used.
v5.8: Added a handler for Ctrl+C (KeyboardInterrupt) to exit gracefully
      without deleting the source file.
v5.7: CRITICAL FIX: Replaced ffmpeg -n flag with a robust 3-point check
      (existence, modification, validity) before deleting a source file to
      prevent data loss on a failed overwrite.
v5.6: Reworked filename suffix logic to handle all cases correctly.
v5.5: Prevent adding .REMUX suffix to filenames that already contain .CONV.
v5.4: Filename sanitization now also replaces underscores (_) with periods.
v5.3: Use .REMUX.mkv suffix for --remux operations instead of .CONV.mkv.
v5.2: Modified --subs to accept multiple files and set language metadata.
v5.1: Changed default output name for single files to include the .CONV
      suffix, matching the behavior of batch mode for consistency.
v5.0: Added interactive Stream Filtering mode (-k, --filter-streams).
"""

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')

# --- Helper Functions ---

# --- MODIFICATION START ---
# NEW function to get video duration for the progress bar.
def get_video_duration(file_path):
    """Uses ffprobe to get the duration of a video file in seconds."""
    ffprobe_cmd = [
        'ffprobe', '-v', 'error', '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1', file_path
    ]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return float(result.stdout.strip())
    except (FileNotFoundError, subprocess.CalledProcessError, ValueError):
        print(f"Warning: Could not get video duration for '{file_path}'. Progress bar disabled.", file=sys.stderr)
        return None
# --- MODIFICATION END ---

def get_stream_info(file_path):
    """Uses ffprobe to get structured information about all streams in a file."""
    ffprobe_cmd = [
        'ffprobe', '-v', 'quiet', '-print_format', 'json',
        '-show_streams', file_path
    ]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return json.loads(result.stdout).get('streams', [])
    except (FileNotFoundError, subprocess.CalledProcessError, json.JSONDecodeError):
        print(f"Error: Could not get stream information from '{file_path}'.", file=sys.stderr)
        return None

def plan_stream_selection(streams):
    """Determains which streams to keep or remove based on defined criteria."""
    streams_to_keep = []
    streams_to_remove = []
    for s in streams:
        keep_stream = False
        stream_type = s.get('codec_type')
        tags = s.get('tags', {})
        lang = tags.get('language', 'und').lower()
        title = tags.get('title', '').lower()

        if stream_type == 'video':
            keep_stream = True
        elif stream_type == 'audio':
            if lang == 'eng' or 'commentary' in title or 'director' in title:
                keep_stream = True
        elif stream_type == 'subtitle':
            if lang == 'eng':
                keep_stream = True

        if keep_stream:
            streams_to_keep.append(s)
        else:
            streams_to_remove.append(s)
    return streams_to_keep, streams_to_remove

def display_and_confirm_plan(streams_to_keep, streams_to_remove):
    """Displays the stream selection plan and asks the user for confirmation."""
    print("\n--- Stream Selection Plan ---")
    print("The following streams will be KEPT:")
    if not streams_to_keep:
        print("  - None")
    for s in streams_to_keep:
        stype = s.get('codec_type', 'unknown').capitalize()
        lang = s.get('tags', {}).get('language', 'und')
        title = s.get('tags', {}).get('title')
        title_str = f" - Title: {title}" if title else ""
        print(f"  - Stream #{s['index']} ({stype}): Lang: {lang}{title_str}")

    print("\nThe following streams will be REMOVED:")
    if not streams_to_remove:
        print("  - None")
    for s in streams_to_remove:
        stype = s.get('codec_type', 'unknown').capitalize()
        lang = s.get('tags', {}).get('language', 'und')
        title = s.get('tags', {}).get('title')
        title_str = f" - Title: {title}" if title else ""
        print(f"  - Stream #{s['index']} ({stype}): Lang: {lang}{title_str}")
    
    print("-----------------------------")
    try:
        choice = input("Proceed with this selection? [y/N]: ").lower().strip()
        return choice == 'y'
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        return False


def format_bytes(size_bytes):
    """Converts a byte value into a human-readable string (KB, MB, GB)."""
    if size_bytes is None or size_bytes == 0:
        return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return f"{s} {size_name[i]}"

def print_size_summary(original_bytes, new_bytes):
    """Calculates and prints a summary of the file size change."""
    if original_bytes is None or new_bytes is None:
        return
    print("\n--- File Size Summary ---")
    print(f"Original Size: {format_bytes(original_bytes)}")
    print(f"New Size     : {format_bytes(new_bytes)}")
    if original_bytes > 0:
        difference_bytes = original_bytes - new_bytes
        percentage = (difference_bytes / original_bytes) * 100
        if difference_bytes > 0:
            print(f"Space Saved  : {format_bytes(difference_bytes)} ({percentage:.2f}% reduction)")
        else:
            print(f"Size Increase: {format_bytes(abs(difference_bytes))} ({abs(percentage):.2f}% increase)")
    print("-------------------------")


def find_video_files(input_path, recursive):
    """Finds all video files in a given path."""
    video_files = []
    if recursive:
        for root, _, files in os.walk(input_path):
            for file in files:
                if file.lower().endswith(VIDEO_EXTENSIONS):
                    video_files.append(os.path.join(root, file))
    else:
        for file in os.listdir(input_path):
            if file.lower().endswith(VIDEO_EXTENSIONS):
                video_files.append(os.path.join(input_path, file))
    return video_files

def is_hevc(file_path):
    """Checks if the video codec of a file is HEVC."""
    if not os.path.exists(file_path):
        return False
    ffprobe_cmd = [
        'ffprobe', '-v', 'error', '-select_streams', 'v:0',
        '-show_entries', 'stream=codec_name', '-of',
        'default=noprint_wrappers=1:nokey=1', file_path
    ]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return 'hevc' in result.stdout.lower()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def print_ffmpeg_command(cmd):
    """Prints the command in a copy-pasteable format."""
    print("\nExecuting FFmpeg command (Dry Run):")
    cmd_str = ' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd)
    print(cmd_str)

# --- MODIFICATION START ---
# This function is heavily reworked to handle the progress bar.
def run_ffmpeg_command(cmd, source_file, delete_source, is_remux=False, is_quiet=False):
    """Executes the FFmpeg command, shows a progress bar, and handles the output."""
    print("\nExecuting FFmpeg command:")
    cmd_str = ' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd)
    print(cmd_str)
    
    output_file = cmd[-1]
    original_size = os.path.getsize(source_file) if os.path.exists(source_file) else None
    
    # Fallback to simple execution for remuxing (too fast) or quiet mode
    if is_remux or is_quiet:
        print("\n(Progress bar is disabled for remux or quiet mode)")
        try:
            # Use original subprocess.run for simplicity here
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print(f"\nError: FFmpeg failed with exit code {e.returncode}.", file=sys.stderr)
            print("Source file was NOT deleted.")
            sys.exit(1)
        # Continue to safety checks below
    else:
        # Progress bar execution for transcodes
        total_duration = get_video_duration(source_file)
        if not total_duration:
            print("\nCould not get duration, running FFmpeg without progress...")
            try:
                subprocess.run(cmd, check=True)
            except subprocess.CalledProcessError as e:
                print(f"\nError: FFmpeg failed with exit code {e.returncode}.", file=sys.stderr)
                print("Source file was NOT deleted.")
                sys.exit(1)
        else:
            try:
                time_pattern = re.compile(r"time=(\d{2}):(\d{2}):(\d{2})\.(\d{2})")
                
                process = subprocess.Popen(cmd, stderr=subprocess.PIPE, stdout=subprocess.DEVNULL,
                                           universal_newlines=True, encoding='utf-8')
                
                with tqdm(total=round(total_duration), unit='s', dynamic_ncols=True, desc="Transcoding") as pbar:
                    for line in process.stderr:
                        match = time_pattern.search(line)
                        if match:
                            h, m, s, ms = map(int, match.groups())
                            elapsed_seconds = h * 3600 + m * 60 + s + ms / 100
                            pbar.update(round(elapsed_seconds - pbar.n))

                process.wait()
                if process.returncode != 0:
                     print(f"\nError: FFmpeg failed with exit code {process.returncode}.", file=sys.stderr)
                     print("Source file was NOT deleted.")
                     sys.exit(1)

            except FileNotFoundError:
                print("\nError: 'ffmpeg' or 'ffprobe' not found. Is FFmpeg installed and in your PATH?", file=sys.stderr)
                sys.exit(1)
            except KeyboardInterrupt:
                print("\nOperation cancelled by user (Ctrl+C).")
                process.terminate()
                print("Source file was NOT deleted.")
                sys.exit(1)

    # --- This entire section remains the same, but now runs AFTER the progress bar logic ---
    original_mtime = None
    if os.path.exists(output_file):
        try:
            original_mtime = os.path.getmtime(output_file)
        except OSError:
            pass 

    # --- Start of 3-Point Safety Check ---
    if not os.path.exists(output_file):
        print(f"\nError: FFmpeg finished, but output file '{output_file}' was not created.", file=sys.stderr)
        print("Source file was NOT deleted.")
        sys.exit(1)
        
    if original_mtime is not None:
        try:
            if os.path.getmtime(output_file) <= original_mtime:
                print(f"\nWarning: Output file '{output_file}' was not modified.", file=sys.stderr)
                print("Source file was NOT deleted.")
                sys.exit(1)
        except OSError:
            print(f"\nError: Could not verify modification time of output file '{output_file}'.", file=sys.stderr)
            print("Source file was NOT deleted.")
            sys.exit(1)

    try:
        subprocess.run(['ffprobe', '-v', 'error', output_file], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print(f"\nError: FFmpeg finished, but output file '{output_file}' appears to be invalid.", file=sys.stderr)
        print("Source file was NOT deleted.")
        sys.exit(1)
    
    # --- End of 3-Point Safety Check ---

    print(f"\nSuccessfully created and verified '{output_file}'.")
    new_size = os.path.getsize(output_file) if os.path.exists(output_file) else None
    print_size_summary(original_size, new_size)
    
    if delete_source:
        print(f"\nInfo: --delete flag is set. Deleting source file...")
        try:
            os.remove(source_file)
            print(f"Successfully deleted: {source_file}")
        except OSError as e:
            print(f"\nError: Could not delete source file '{source_file}'. Reason: {e}", file=sys.stderr)
# --- MODIFICATION END ---


# --- Main Logic ---
def main():
    """Parses arguments and performs media operations."""
    if '-v' in sys.argv or '--version' in sys.argv:
        print(VERSION_HISTORY)
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="A tool to transcode or remux video files using Intel QSV.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Examples:
  # Transcode a file, intelligently keeping only English/Commentary tracks
  ,hvec -i "My Movie.mkv" -k

  # Transcode a directory, deleting originals, and filtering all files
  ,hvec -i /path/to/videos/ -D -k
"""
    )
    # --- All Arguments Defined Here ---
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    parser.add_argument("-o", "--output", help="Output MKV file. If specified, name sanitization is skipped.")
    parser.add_argument("-k", "--filter-streams", action="store_true", help="Interactively filter audio/subtitle streams to keep English and commentary tracks.")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete the original input file after a successful transcode.")
    parser.add_argument("--out-dir", help="Output directory for batch processing. Preserves source folder structure.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process files in subdirectories when -i is a directory.")
    parser.add_argument("-s", "--subs", nargs='+', help="One or more external subtitle files to embed (e.g. --subs sub1.srt sub2.srt).")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force output to be HEVC/H.265. Overrides --remux.")
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set QSV quality for video (1-51, lower is better). Default: 24.")
    parser.add_argument("-p", "--preset", type=str, default='medium',
                        choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'],
                        help="Set QSV encoding preset. Slower presets offer better compression. Default: medium.")
    parser.add_argument("--acodec", help="Re-encode audio to a specific codec (e.g., aac, ac3). Default: copy.")
    parser.add_argument("--abitrate", help="Set audio bitrate when re-encoding (e.g., 192k, 384k).")
    parser.add_argument("--skip-hevc", action="store_true", help="In batch mode, skip transcoding files that are already H.265/HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print the FFmpeg commands without executing them.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux instead of transcoding.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress FFmpeg's console output. Disables progress bar.")
    parser.add_argument("--less-noise", action="store_true", help="Show progress updates only every 30 seconds.")
    parser.add_argument("-v", "--version", action="store_true", help="Show the version history and exit.")

    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    print(f",hvec v{__version__}")

    files_to_process = []
    if not os.path.exists(args.input):
        print(f"Error: Input path not found: '{args.input}'", file=sys.stderr)
        sys.exit(1)

    if os.path.isdir(args.input):
        print(f"\nInput is a directory. Scanning for video files...")
        files_to_process = find_video_files(args.input, args.recursive)
        print(f"Found {len(files_to_process)} video files to process.")
    else:
        files_to_process.append(args.input)

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        
        if args.skip_hevc and is_hevc(input_file):
            print("Video is already HEVC. Skipping.")
            continue

        output_file = ""
        
        def generate_output_filename(base_name, is_remux):
            sanitized_base = base_name.replace('(', '').replace(')', '').replace(' ', '.').replace('_', '.')
            suffix_part = ".REMUX" if is_remux else ".CONV"
            if sanitized_base.endswith(suffix_part):
                return sanitized_base + '.mkv'
            else:
                return sanitized_base + suffix_part + '.mkv'

        if len(files_to_process) > 1:
            base_name, _ = os.path.splitext(os.path.basename(input_file))
            new_filename = generate_output_filename(base_name, args.remux)
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input)
                output_dir = os.path.join(args.out_dir, relative_path)
                if not os.path.exists(output_dir):
                    os.makedirs(output_dir)
                output_file = os.path.join(output_dir, new_filename)
            else:
                output_file = os.path.join(os.path.dirname(input_file), new_filename)
        else:
            if args.output:
                output_file = args.output
            else:
                base_name, _ = os.path.splitext(input_file)
                output_file = generate_output_filename(base_name, args.remux)
        
        # --- COMMAND BUILDING LOGIC ---
        ffmpeg_cmd = ['ffmpeg']
        
        # --- MODIFICATION START ---
        # Added -stats to ensure progress is shown even with loglevel changes,
        # but quiet mode will still override it in run_ffmpeg_command.
        if args.quiet:
            ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        elif args.less_noise:
            ffmpeg_cmd.extend(['-stats_period', '30'])
        else:
            # This ensures the time= field is printed for the progress bar.
            ffmpeg_cmd.extend(['-v', 'error', '-stats'])
        # --- MODIFICATION END ---
        
        ffmpeg_cmd.extend(['-hwaccel', 'qsv', '-i', input_file])

        # --- STREAM MAPPING LOGIC ---
        if args.filter_streams:
            all_streams = get_stream_info(input_file)
            if all_streams is None:
                continue 
            streams_to_keep, streams_to_remove = plan_stream_selection(all_streams)
            if not display_and_confirm_plan(streams_to_keep, streams_to_remove):
                print("Skipping file as per user request.")
                continue
            for stream in streams_to_keep:
                ffmpeg_cmd.extend(['-map', f"0:{stream['index']}"])
        elif args.subs:
            if len(files_to_process) > 1:
                print("Warning: External subtitles (--subs) are only supported for single file processing. Ignoring.")
                ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '0:s?'])
            else:
                for sub_file in args.subs:
                    if not os.path.exists(sub_file):
                        print(f"Error: Subtitle file not found: '{sub_file}'", file=sys.stderr)
                        continue
                    ffmpeg_cmd.extend(['-i', sub_file])
                ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?'])
                for i in range(len(args.subs)):
                    ffmpeg_cmd.extend(['-map', f'{i+1}:s:0'])
                    ffmpeg_cmd.extend([f'-metadata:s:s:{i}', 'language=eng'])
        else:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '0:s?'])

        # --- CODEC AND OUTPUT LOGIC ---
        is_remux_op = args.remux and not args.hvec
        if is_remux_op:
            print("Mode: Lossless Remux")
            ffmpeg_cmd.extend(['-c', 'copy'])
            if args.subs:
                ffmpeg_cmd.extend(['-c:s', 'srt'])
        else:
            print("\nMode: QSV Transcode")
            ffmpeg_cmd.extend(['-c:v', 'hevc_qsv', '-preset', args.preset, '-global_quality', str(args.quality)])
            if args.acodec:
                print(f"Re-encoding audio to {args.acodec.upper()}")
                ffmpeg_cmd.extend(['-c:a', args.acodec])
                if args.abitrate:
                    ffmpeg_cmd.extend(['-b:a', args.abitrate])
            else:
                ffmpeg_cmd.extend(['-c:a', 'copy'])
            
            if args.subs:
                ffmpeg_cmd.extend(['-c:s', 'srt'])
            else:
                ffmpeg_cmd.extend(['-c:s', 'copy'])
            
        ffmpeg_cmd.append(output_file)
        
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
            if args.delete:
                print(f"Info: Source file '{input_file}' would be deleted upon success.")
        else:
            # --- MODIFICATION START ---
            # Pass new flags to the command runner function
            run_ffmpeg_command(ffmpeg_cmd, input_file, args.delete, is_remux=is_remux_op, is_quiet=args.quiet)
            # --- MODIFICATION END ---

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()