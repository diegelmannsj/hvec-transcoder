#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete
import re
import shutil
from tqdm import tqdm
import grp
from typing import Dict, Any, List
import csv
import time

# --- Version History ---
__version__ = "8.2.5"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v8.2.5  fix(ffmpeg): *Always* copy subtitle streams
        
        - A bug in the transcode logic was forcing subtitle
          conversion with '-c:s srt'.
        - This failed on bitmap (image) subtitles like
          PGS or VobSub, which cannot be converted to
          text-based SRT.
        - The logic is now fixed to *always* use
          '-c:s copy' for both transcode and remux
          operations, as MKV containers can store all
          subtitle types.

v8.2.4  fix(ffmpeg): *FINAL* explicit copy for -filter_complex
        
        - This is the final fix for the "Filter/Copy"
          conflict in "Add" mode.
        - The previous version (8.2.3) correctly used
          -filter_complex but re-introduced a global
          '-c:a copy' flag.
        - This global flag conflicted with the input stream
          [0:a:0] which was being used in the filter.
        - The logic now combines both fixes:
          1. Uses '-filter_complex ... [a_norm]'
          2. Maps '[a_norm]' to 'a:0'
          3. Maps '0:a?' to 'a:1', 'a:2', etc.
          4. Applies the 'aac' codec *only* to 'a:0'.
          5. *Explicitly* loops and applies '-c:a:1 copy',
             '-c:a:2 copy', etc. to all other streams.
        - This finally resolves the conflict.

v8.2.3  fix(ffmpeg): (Failed attempt) *FINAL* fix for "Filter/Copy"
        conflict using -filter_complex for "Add" mode.
v8.2.2  fix(ffmpeg): (Failed attempt) *FINAL* fix for "Filtergraph
        specified but codec copy selected" in "Add" mode.
v8.2.1  fix(main): Correct typo 'add_Sargument' to 'add_argument'
v8.2.0  feat(normalize): Add non-destructive "Add" mode for -N
v8.1.15 fix(ffmpeg): *FINAL* fix for contradictory audio/filter logic
        ...
"""
# --- MODIFICATION END ---

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')
SUBTITLE_EXTENSIONS = ('.srt', '.ass', '.sub')

DEFAULT_LOG_BASENAME = 'audit_loudness.csv'
DEFAULT_LOG_DIR = os.path.expanduser('~/.hvec')
DEFAULT_LOG_PATH = os.path.join(DEFAULT_LOG_DIR, DEFAULT_LOG_BASENAME)
CWD_LOG_PATH = os.path.abspath(DEFAULT_LOG_BASENAME)

# --- Helper Functions ---
def get_total_frames(file_path):
    """Gets total frames quickly using mediainfo (preferred) or falls back."""
    if shutil.which('mediainfo'):
        cmd = ['mediainfo', '--Inform=Video;%FrameCount%', file_path]
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            return int(result.stdout.strip())
        except (subprocess.CalledProcessError, ValueError, FileNotFoundError):
            pass
  
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=duration,avg_frame_rate', '-of', 'json', file_path]
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        data = json.loads(result.stdout)['streams'][0]
        if 'duration' not in data or 'avg_frame_rate' not in data: return None
        duration, fr_str = float(data['duration']), data['avg_frame_rate']
        if '/' in fr_str:
            n, d = map(int, fr_str.split('/')); frame_rate = n / d if d != 0 else 0
        else: frame_rate = float(fr_str)
        if duration <= 0 or frame_rate <= 0: return None
        return int(duration * frame_rate)
    except Exception: return None

def get_stream_info(file_path):
    """Uses ffprobe to get structured information about all streams in a file."""
    ffprobe_cmd = ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', file_path]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return json.loads(result.stdout).get('streams', [])
    except Exception:
        print(f"Error: Could not get stream information from '{file_path}'.", file=sys.stderr); return None

def plan_stream_selection(streams):
    streams_to_keep, streams_to_remove = [], []
    for s in streams:
        keep = False; stype = s.get('codec_type'); tags = s.get('tags', {}); lang = tags.get('language', 'und').lower(); title = s.get('title', '').lower()
        if stype == 'video' or (stype == 'audio' and (lang == 'eng' or 'commentary' in title or 'director' in title)) or (stype == 'subtitle' and lang == 'eng'): keep = True
        if keep: streams_to_keep.append(s)
        else: streams_to_remove.append(s)
    return streams_to_keep, streams_to_remove

def display_and_confirm_plan(s_keep, s_rem):
    print("\n--- Stream Selection Plan ---\nKEPT:"); [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_keep]
    print("\nREMOVED:"); [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_rem]
    try: return input("Proceed? [y/N]: ").lower().strip() == 'y'
    except KeyboardInterrupt: return False

def format_size(size_bytes):
    """Converts a size in bytes to a human-readable string using binary prefixes."""
    if size_bytes is None or not isinstance(size_bytes, (int, float)) or size_bytes < 0: return "N/A"
    if size_bytes == 0: return "0 B"
    size_name = ("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB")
    try:
        i = int(math.floor(math.log(size_bytes, 1024))); i = min(i, len(size_name) - 1)
        p = math.pow(1024, i); s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"
    except (ValueError, TypeError): return "N/A"

def print_size_summary(original_size_bytes, new_size_bytes, audio_normalized=False):
    """Prints a formatted summary of the file size change."""
    print("\n--- File Size Summary ---")
    original_size_str = format_size(original_size_bytes); new_size_str = format_size(new_size_bytes)
    print(f"Original:   {original_size_str}"); print(f"New:         {new_size_str}")
    if original_size_bytes is not None and new_size_bytes is not None and original_size_bytes > 0:
        difference_bytes = new_size_bytes - original_size_bytes; percentage_change = (difference_bytes / original_size_bytes) * 100
        change_type = "increase" if difference_bytes >= 0 else "decrease"; difference_str = format_size(abs(difference_bytes))
        print(f"Difference: {difference_str} ({abs(percentage_change):.2f}% {change_type})")
    else: print("Difference: N/A")
    
    if audio_normalized:
        print("Audio:      Normalized (EBU R128)")
    
    print("-------------------------")

def find_video_files(p, r):
    vids = [];
    if r: [vids.extend([os.path.join(root, f) for f in files if f.lower().endswith(VIDEO_EXTENSIONS)]) for root, _, files in os.walk(p)]
    else: vids.extend([os.path.join(p, f) for f in os.listdir(p) if f.lower().endswith(VIDEO_EXTENSIONS)])
    return vids

def is_hevc(f):
    if not os.path.exists(f): return False
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=codec_name', '-of', 'default=noprint_wrappers=1:nokey=1', f]
    try: return 'hevc' in subprocess.run(cmd, check=True, capture_output=True, text=True).stdout.lower()
    except Exception: return False

def print_ffmpeg_command(cmd):
    """Prints the FFmpeg command for dry-run mode."""
    print("\nExecuting FFmpeg command (Dry Run):")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))

# --- MODIFIED: Using fast ebur128 analysis (v8.0.0) ---
def run_loudnorm_analysis(input_file: str) -> Dict[str, float] or None:
    """
    Runs the FFmpeg ebur128 analysis on a single file.
    This is much faster than the loudnorm filter.
    """
    start_time = time.time() # <-- This line needs 'import time'
    cmd = [
        'ffmpeg', '-nostdin', '-i', input_file,
        '-threads', '0',  # Use all available threads
        '-map', '0:a:0',  # Analyze the first audio stream
        '-af', 'ebur128=peak=true', # Use the ebur128 filter
        '-f', 'null', '-'
    ]
    
    try:
        # The ebur128 filter writes all its output to stderr.
        result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8', timeout=1200)
        
        stderr_output = result.stderr
        
        if not stderr_output:
            print("Error: No output from ffmpeg analysis.", file=sys.stderr)
            return None

        # --- Regex patterns to find the 4 values ---
        patterns = {
            'i':      re.compile(r"Integrated loudness:\s+I:\s*(-?[\d\.]+)\s+LUFS"),
            'thresh': re.compile(r"Integrated loudness:\s+I:.*?\s+Threshold:\s*(-?[\d\.]+)\s+LUFS"),
            'lra':    re.compile(r"Loudness range:\s+LRA:\s*(-?[\d\.]+)\s+LU"),
            'tp':     re.compile(r"True peak:\s+Peak:\s*(-?[\d\.]+)\s+dBFS")
        }
        
        loudness_data = {}
        missing_keys = []
        
        for key, pattern in patterns.items():
            match = pattern.search(stderr_output)
            if match:
                loudness_data[key] = float(match.group(1))
            else:
                missing_keys.append(key)

        if missing_keys:
            if "Stream map '0:a:0' matches no streams" in stderr_output:
                return None # Return None, main loop will print warning
            else:
                print(f"Error: Could not parse ebur128 output. Missing: {', '.join(missing_keys)}", file=sys.stderr)
                return None

        return loudness_data
        
    except subprocess.TimeoutExpired:
        print("Error: Audio analysis process timed out (20 minutes)", file=sys.stderr)
        return None
    except FileNotFoundError:
        print("Error: ffmpeg command not found in PATH", file=sys.stderr)
        return None
    except Exception as e:
        print(f"\nAn unexpected error occurred during audio analysis: {e}", file=sys.stderr)
        return None
# --- END MODIFIED ---

def embed_chapters_mkvpropedit(chapter_file, output_file):
    """Embeds chapters into an existing MKV file using mkvpropedit."""
    if not shutil.which('mkvpropedit'):
        print("\nError: 'mkvpropedit' command not found. Please install MKVToolNix.", file=sys.stderr)
        return False
    if not os.path.exists(chapter_file):
        print(f"\nError: Chapter file not found at '{chapter_file}'.", file=sys.stderr)
        return False
    if not os.path.exists(output_file):
        print(f"\nError: Output MKV file '{output_file}' not found for chapter embedding.", file=sys.stderr)
        return False

    mkvpropedit_cmd = ['mkvpropedit', output_file, '--chapters', chapter_file]
    print("\nExecuting mkvpropedit command:")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in mkvpropedit_cmd))

    try:
        # Capture output to check for errors/warnings
        result = subprocess.run(mkvpropedit_cmd, check=True, capture_output=True, text=True)
        # mkvpropedit often prints progress or confirmations to stdout/stderr even on success
        if result.stdout: print("mkvpropedit output:", result.stdout)
        if result.stderr: print("mkvpropedit errors/warnings:", result.stderr)
        print(f"Successfully embedded chapters into '{os.path.basename(output_file)}'.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"\n--- mkvpropedit Error ---", file=sys.stderr)
        print(f"Command failed with exit code {e.returncode}", file=sys.stderr)
        if e.stdout: print("stdout:", e.stdout, file=sys.stderr)
        if e.stderr: print("stderr:", e.stderr, file=sys.stderr)
        print(f"-------------------------", file=sys.stderr)
        return False
    except Exception as e:
        print(f"\nAn unexpected error occurred running mkvpropedit: {e}", file=sys.stderr)
        return False

# --- MODIFIED: Added args.verbose to signature (v8.1.0) ---
def run_ffmpeg_command(cmd, source_file, delete_source, audio_normalized=False, total_frames=None, permissions=None, chapter_file_to_embed=None, verbose=False):
    """Executes FFmpeg, shows progress, verifies output, and optionally embeds chapters."""
    print("\nExecuting FFmpeg command:")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))
    output_file = cmd[-1]
    original_size_bytes = os.path.getsize(source_file) if os.path.exists(source_file) else None
    
    # --- FFmpeg Execution ---
    ffmpeg_success = False
    try:
        if "-progress" not in cmd:
            subprocess.run(cmd, check=True)
        else:
            if total_frames is None: print("\nWarning: Could not get total frames. Progress bar indeterminate.")
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8')
            with tqdm(total=total_frames, unit='frame', dynamic_ncols=True, desc="FFmpeg") as pbar:
                for line in process.stdout:
                    if line.strip().startswith("frame="):
                        current_frame = int(line.strip().split("=")[1]); pbar.update(max(0, current_frame - pbar.n))
            stderr_output = process.stderr.read(); process.wait()
            if process.returncode != 0: raise subprocess.CalledProcessError(process.returncode, cmd, stderr=stderr_output)
        ffmpeg_success = True
    except (subprocess.CalledProcessError, FileNotFoundError, KeyboardInterrupt) as e:
        if isinstance(e, subprocess.CalledProcessError): print(f"\n--- FFmpeg Error --\n{e.stderr}\n--------------------", file=sys.stderr)
        elif isinstance(e, FileNotFoundError): print("\nError: Required command not found (ffmpeg/stdbuf).", file=sys.stderr)
        else: print("\nCancelled.", file=sys.stderr)
        if 'process' in locals(): process.terminate()
        sys.exit(1) # Exit immediately on FFmpeg failure

    # --- Post-FFmpeg Verification ---
    if not ffmpeg_success or not os.path.exists(output_file):
        print(f"\nError: FFmpeg failed or output file '{output_file}' not created.", file=sys.stderr); sys.exit(1)
    try:
        new_size_bytes = os.path.getsize(output_file)
        subprocess.run(['ffprobe', '-v', 'error', output_file], check=True, capture_output=True)
    except Exception:
        print(f"\nError: Output file '{output_file}' appears invalid after FFmpeg.", file=sys.stderr); sys.exit(1)
    
    print(f"\nSuccessfully created and verified FFmpeg output '{output_file}'.")
    
    # --- Chapter Embedding (NEW STEP) ---
    chapters_embedded_successfully = True # Assume success if not requested
    if chapter_file_to_embed:
        chapters_embedded_successfully = embed_chapters_mkvpropedit(chapter_file_to_embed, output_file)
        if not chapters_embedded_successfully:
            print(f"\nError: Failed to embed chapters using mkvpropedit. Output file '{output_file}' may be incomplete.", file=sys.stderr)
            # Decide if you want to exit here or continue. For now, we continue but warn.
            # sys.exit(1)
    # --- END Chapter Embedding ---

    # --- Permissions ---
    if permissions:
        try:
            os.chown(output_file, permissions['uid'], permissions['gid']); os.chmod(output_file, permissions['mode'])
            # --- MODIFIED: Added verbose check (v8.1.0) ---
            if verbose:
                print(f"Info: Applied permissions to '{os.path.basename(output_file)}'.")
        except OSError as e: print(f"\nWarning: Could not set permissions. Reason: {e}", file=sys.stderr)

    print_size_summary(original_size_bytes, new_size_bytes, audio_normalized=audio_normalized)
    
    # --- Delete Source ---
    # Only delete if BOTH FFmpeg AND chapter embedding (if requested) were successful
    if delete_source and ffmpeg_success and chapters_embedded_successfully:
        print(f"\nInfo: --delete flag set. Deleting source file...")
        try:
            os.remove(source_file); print(f"Successfully deleted: {source_file}")
        except OSError as e: print(f"\nError: Could not delete source '{source_file}'. Reason: {e}", file=sys.stderr)
    elif delete_source:
         print(f"\nWarning: --delete flag ignored because chapter embedding failed.")

# --- MODIFIED: Added args.verbose to signature (v8.1.0) ---
def load_loudness_db(log_file: str, verbose=False) -> Dict[str, Dict[str, float]]:
    """
    Reads a CSV loudness audit log file and returns a
    dictionary mapping file paths to their normalization data.
    """
    db = {}
    
    if not os.path.exists(log_file):
        print(f"Warning: Loudness log not found at '{log_file}'. Will run analysis.", file=sys.stderr)
        return db

    # --- MODIFIED: Added verbose check (v8.1.0) ---
    if verbose:
        print(f"Info: Loading loudness database from '{os.path.basename(log_file)}'...")
    try:
        with open(log_file, 'r', encoding='utf-8', newline='') as f:
            # Use DictReader to read the log by header name
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    if row.get('Status') == 'SUCCESS':
                        file_path = row.get('File', '').strip()
                        if not file_path:
                            continue
                            
                        # Keys must match what run_loudnorm_analysis returns
                        data = {
                            'i': float(row['CurrentLoudness']),
                            'tp': float(row['MeasuredTP']),
                            'lra': float(row['MeasuredLRA']),
                            'thresh': float(row['MeasuredThresh'])
                        }
                        db[file_path] = data
                except (ValueError, KeyError, TypeError, AttributeError):
                    # Ignore malformed or non-SUCCESS lines
                    pass
    except Exception as e:
        print(f"Error: Could not read loudness log '{log_file}': {e}", file=sys.stderr)
    
    # --- MODIFIED: Added verbose check (v8.1.0) ---
    if verbose:
        print(f"Info: Loaded {len(db)} pre-analyzed entries.")
    return db
# --- END MODIFIED ---


# --- Main Logic ---
def main():
    print(f",hvec v{__version__}") # Print current version first

    # --- Argument Parser ---
    parser = argparse.ArgumentParser(description="A tool to transcode or remux files using Intel VAAPI.", formatter_class=argparse.RawTextHelpFormatter, epilog="Examples:\n  ,hvec -i \"My Movie.mkv\" -k\n  ,hvec -i /videos/ -D -k -R\n  ,hvec -i movie.mp4 -r -C chapters.txt\n  ,hvec -i movie.mkv -N /path/to/loudness_audit.csv") # <-- MODIFIED Example
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    # --- MODIFIED: Fixed typo (v8.2.1) ---
    parser.add_argument("-o", "--output", help="Output MKV file (single file mode only).")
    # --- END MODIFIED ---
    parser.add_argument("-k", "--filter-streams", action="store_true", help="Interactively filter streams (single file mode only).")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete original file after success.")
    parser.add_argument("--out-dir", help="Output directory for batch processing.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process subdirectories.")
    parser.add_argument("-C", "--chapters", help="External chapter file (TXT/OGM or XML) to embed (requires MKVToolNix).")
    parser.add_argument("-s", "--subs", nargs='+', help="External subtitle files to embed (single file mode only).")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force HEVC output (overrides --remux).")
    
    # --- MODIFIED: -N now optionally takes a value (v7.8) ---
    parser.add_argument(
        "-N", "--normalize", 
        nargs='?', 
        const=True, 
        default=None, 
        help="Normalize audio to EBU R128 (-23 LUFS).\n"
             "Optionally provide a path to a loudness_audit.csv file \n" # <-- MODIFIED Example
             "to skip analysis and use pre-scanned values."
    )
    # --- END MODIFIED ---
    
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set VAAPI quality (1-51).")
    parser.add_argument("-p", "--preset", type=str, default='medium', choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'], help="Set encoding preset.")
    parser.add_argument("--acodec", help="Re-encode audio codec (e.g., 'aac', 'ac3'). Default: 'copy'.")
    parser.add_argument("--abitrate", help="Set audio bitrate (e.g., '192k', '384k').")
    parser.add_argument("--skip-hevc", action="store_true", help="Skip files that are already HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print commands without executing.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux (instead of transcode).")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress FFmpeg output.")
    parser.add_argument("-v", "--version", action="store_true", help="Show version history and exit.")
    
    # --- MODIFIED: Added verbose flag (v8.1.0) ---
    parser.add_argument("-V", "--verbose", action="store_true", help="Print detailed information during processing.")
    
    # --- MODIFIED: Added back argcomplete (v8.1.2) ---
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    # --- END MODIFIED ---
    
    # --- MODIFIED: Added verbose check (v8.1.0) ---
    if args.verbose:
        print("Info: Verbose mode enabled.")
    
    # --- MODIFIED: Corrected indentation (v8.0.2) ---
    if args.version:
        print(VERSION_HISTORY)
        sys.exit(0) # Handle --version flag
    # --- END MODIFIED ---

    # --- MODIFIED: Corrected indentation (v8.0.3) ---
    if not os.path.exists(args.input):
        print(f"Error: Input path not found: {args.input}", file=sys.stderr); sys.exit(1)
    # --- END MODIFIED ---
    
    # --- MODIFIED: Load Loudness DB (v8.1.4) ---
    loudness_db = {}
    is_normalize_enabled = args.normalize is not None
    analysis_data = None # <-- MODIFIED: Define analysis_data up here
    
    if isinstance(args.normalize, str):
        # Path provided, e.g., -N /path/to/log.csv
        if args.verbose:
            print(f"Info: User specified loudness log: {args.normalize}")
        loudness_db = load_loudness_db(args.normalize, args.verbose)
    
    elif is_normalize_enabled:
        # No path provided, e.g., -N
        # Check CWD first
        if os.path.exists(CWD_LOG_PATH):
            if args.verbose:
                print(f"Info: Found loudness log in CWD: {CWD_LOG_PATH}")
            loudness_db = load_loudness_db(CWD_LOG_PATH, args.verbose)
        # If not in CWD, check default ~/.hvec path
        elif os.path.exists(DEFAULT_LOG_PATH):
            if args.verbose:
                print(f"Info: Found loudness log in default path: {DEFAULT_LOG_PATH}")
            loudness_db = load_loudness_db(DEFAULT_LOG_PATH, args.verbose)
        else:
            if args.verbose:
                print(f"Info: No loudness log found in CWD or default path. Will run live analysis.")
    # --- END MODIFIED ---
    
    # --- File Processing Loop ---
    files_to_process = find_video_files(args.input, args.recursive) if os.path.isdir(args.input) else [args.input]
    
    # --- MODIFIED: Corrected indentation (v8.0.4) ---
    if not files_to_process:
        print("No video files found to process.")
        sys.exit(0)
    # --- END MODIFIED ---

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        
        # --- Chapter File Handling ---
        # Store chapter file path separately, disable for batch unless explicitly handled later
        chapter_file_for_this_run = args.chapters
        if chapter_file_for_this_run and len(files_to_process) > 1:
            # --- MODIFIED: Added verbose check (v8.1.0) ---
            if args.verbose:
                print("Info: --chapters flag is ignored in batch/directory mode for now.")
            chapter_file_for_this_run = None # Disable chapters for batch mode
        if chapter_file_for_this_run and not os.path.exists(chapter_file_for_this_run):
             print(f"Warning: Chapter file '{chapter_file_for_this_run}' not found. Skipping chapter embedding.")
             chapter_file_for_this_run = None

        # --- Permissions ---
        permissions_to_apply = None
        try:
            stat_info = os.stat(input_file); input_gid = stat_info.st_gid; input_group_name = grp.getgrgid(input_gid).gr_name
            target_gid = input_gid
            if input_group_name != 'jellyfin':
                try:
                    jellyfin_gid = grp.getgrnam('jellyfin').gr_gid
                    response = input(f"Warning: Source group is '{input_group_name}'. Change output to 'jellyfin'? [Y/n]: ").lower().strip()
                    if response in ('y', 'yes', ''): 
                        target_gid = jellyfin_gid;
                        # --- MODIFIED: Added verbose check (v8.1.0) ---
                        if args.verbose:
                            print("Info: Output group set to 'jellyfin'.")
                except KeyError: 
                    # --- MODIFIED: Added verbose check (v8.1.0) ---
                    if args.verbose:
                        print("Info: 'jellyfin' group not found. Preserving original.")
                except (KeyboardInterrupt, EOFError): print("\nCancelled."); sys.exit(1)
            permissions_to_apply = {'uid': stat_info.st_uid, 'gid': target_gid, 'mode': stat_info.st_mode}
        except (OSError, KeyError) as e: print(f"Warning: Could not read source permissions. Reason: {e}", file=sys.stderr)

        # --- MODIFIED: Corrected indentation (v8.0.5) ---
        if args.skip_hevc and is_hevc(input_file):
            print("Already HEVC. Skipping.")
            continue
        # --- END MODIFIED ---

        # --- Output Filename Generation ---
        is_remux_op = args.remux and not args.hvec # <--- Moved this line up
        is_transcode_op = not is_remux_op # <--- MODIFIED: Added for clarity (v8.1.8)
        
        def generate_output_filename(base, is_remux, has_chapters, is_normalized):
            sanitized = re.sub(r'[\(\)\[\]]', '', base).replace(' ', '.').replace('_', '.') # Cleaner regex
            suffix = ".REMUX" if is_remux else ".CONV"
            chapter_suffix = ".CHAPTERS" if has_chapters else ""
            norm_suffix = ".NORM" if is_normalized else "" # <--- Use our new flag
            # Ensure suffix isn't duplicated, handle case where base already ends with it
            base_no_suffix = sanitized.replace(suffix, '') if sanitized.endswith(suffix) else sanitized
            return f"{base_no_suffix}{suffix}{norm_suffix}{chapter_suffix}.mkv"

        if args.output and len(files_to_process) == 1: output_file = args.output
        else:
            base, _ = os.path.splitext(os.path.basename(input_file)); # Check for suffixes
            has_chapters_flag = chapter_file_for_this_run is not None
            has_normalized_flag = is_normalize_enabled # <--- Use our new flag
            new_filename = generate_output_filename(base, is_remux_op, has_chapters_flag, has_normalized_flag)
            
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input if os.path.isdir(args.input) else os.path.dirname(input_file))
                output_dir = os.path.join(args.out_dir, relative_path); os.makedirs(output_dir, exist_ok=True)
                output_file = os.path.join(output_dir, new_filename)
            else: output_file = os.path.join(os.path.dirname(input_file), new_filename)
        
        # Prevent source overwrite
        if os.path.abspath(output_file) == os.path.abspath(input_file):
            base, ext = os.path.splitext(output_file); output_file = f"{base}.COPY{ext}"
            # --- MODIFIED: Added verbose check (v8.1.0) ---
            if args.verbose:
                print(f"Info: Output name identical to input. Using '{os.path.basename(output_file)}'")
                    
        # --- MODIFIED: Corrected indentation (v8.1.9) ---
        # Overwrite check
        if os.path.exists(output_file) and not args.dry_run:
            try:
                if input(f"Output '{os.path.basename(output_file)}' exists. Overwrite? [y/N]: ").lower().strip() != 'y': 
                    print("Skipping.")
                    continue
            except KeyboardInterrupt:
                print("\nCancelled.")
                sys.exit(1)
        # --- END MODIFIED ---
        
        # --- FFmpeg Command Construction ---
        total_frames = get_total_frames(input_file) if not (is_remux_op or args.quiet or args.dry_run) else None
        
        ffmpeg_cmd = ['ffmpeg', '-y', '-nostdin']
        
        # Progress/Verbosity
        use_progress_bar = total_frames is not None and not (is_remux_op or args.quiet or args.dry_run)
        if use_progress_bar:
            if sys.platform != "win32": ffmpeg_cmd = ['stdbuf', '-o0'] + ffmpeg_cmd
            ffmpeg_cmd.extend(['-progress', '-', '-nostats'])
        elif args.quiet: ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        else: ffmpeg_cmd.extend(['-v', 'error', '-stats'])
        
        # --- HWACCEL & .avi FIX (v7.7) ---
        is_avi = input_file.lower().endswith('.avi')
        
        if is_avi:
            # .avi files almost always need this to fix broken timestamps,
            # for both remuxing and transcoding.
            ffmpeg_cmd.extend(['-fflags', '+genpts'])

        if is_transcode_op and not is_avi:
            # Use hwaccel decode ONLY for non-avi transcodes
            ffmpeg_cmd.extend(['-hwaccel', 'vaapi', '-hwaccel_output_format', 'vaapi'])
        # --- END FIX ---
            
        # --- MODIFIED: Auto-detect sidecar subtitles (v8.0.9) ---
        
        # 1. Gather all external subtitles (manual + auto-detected)
        external_sub_files: List[str] = []
        
        # Add manually specified subs first
        if args.subs:
            for sub_file in args.subs:
                if os.path.exists(sub_file):
                    external_sub_files.append(os.path.abspath(sub_file))
                else:
                    print(f"Warning: Manual subtitle file not found: {sub_file}")
        
        # Auto-detect sidecar files (only in single-file mode)
        if len(files_to_process) == 1:
            # --- MODIFIED: Use abspath to fix relative path bug (v8.1.1) ---
            abs_input_file = os.path.abspath(input_file)
            input_dir = os.path.dirname(abs_input_file)
            # --- END MODIFIED ---
            input_base = os.path.splitext(os.path.basename(input_file))[0]
            
            # --- MODIFIED: Added verbose output (v8.1.0) ---
            if args.verbose:
                print("Info: Scanning for sidecar subtitles...")
                print(f"      - In directory: {input_dir}")
                print(f"      - For base name: {input_base}")
            
            try:
                for item in os.listdir(input_dir):
                    item_path = os.path.join(input_dir, item)
                    item_base, item_ext = os.path.splitext(item)
                    
                    # Check if it's a sub file, matches the base name, and isn't already in our list
                    if item_ext.lower() in SUBTITLE_EXTENSIONS and item_base.startswith(input_base):
                        abs_item_path = os.path.abspath(item_path)
                        if abs_item_path not in external_sub_files:
                            if args.verbose:
                                print(f"Info: Found sidecar: {item}")
                            external_sub_files.append(abs_item_path)
            except OSError as e:
                print(f"Warning: Could not scan for sidecar subtitles: {e}", file=sys.stderr)
            
            if args.verbose and not external_sub_files and not args.subs:
                print("Info: No sidecar or manual subtitles found.")
            # --- END MODIFIED (v8.1.0) ---

        # 2. Add all inputs to ffmpeg command
        ffmpeg_cmd.extend(['-i', input_file]) # Main video input (index 0)
        
        subtitle_input_index = 1 # Starts at 1
        for sub_file in external_sub_files:
            ffmpeg_cmd.extend(['-i', sub_file])
        
        # --- MODIFIED: Reworked Normalization & Mapping Logic (v8.2.4) ---
        
        # 1. Get stream info for prompt and mapping
        all_streams = get_stream_info(input_file) or []
        audio_streams = [s for s in all_streams if s.get('codec_type') == 'audio']
        
        # 2. Decide on normalization mode (Prompt user if needed)
        normalize_mode = 'replace' # Default to old destructive behavior
        
        if is_normalize_enabled and not args.filter_streams:
            has_multichannel = any(s.get('channels', 0) > 2 for s in audio_streams)
            if has_multichannel:
                print("\nInput has multi-channel audio (e.g., 5.1). How to normalize?")
                try:
                    response = input("  [A]dd as new default (Keeps original), [R]eplace, [S]kip: ").lower().strip()
                    if response == 'a':
                        normalize_mode = 'add'
                    elif response == 's':
                        is_normalize_enabled = False # Disable it for this file
                        normalize_mode = 'skip'
                        print("Info: Skipping normalization, will copy audio.")
                    elif response == 'r':
                        normalize_mode = 'replace'
                        print("Info: Will 'Replace' audio stream 0.")
                    else:
                        normalize_mode = 'add' # Default to safest option
                        print(f"Info: Invalid choice. Defaulting to [A]dd.")
                except (KeyboardInterrupt, EOFError):
                    print("\nCancelled.")
                    sys.exit(1)
            else:
                normalize_mode = 'replace' # Not multi-channel, so just replace
                if args.verbose:
                    print("Info: No multi-channel audio found. Using default 'replace' mode.")
        
        elif is_normalize_enabled and args.filter_streams:
             if args.verbose:
                 print("Info: --filter-streams is active. Normalization will 'Replace' mapped streams.")
             normalize_mode = 'replace'

        # 3. Check for/run analysis (MUST be done before mapping)
        filter_string_for_complex = None
        if is_normalize_enabled:
            abs_input_file = os.path.abspath(input_file)
            if abs_input_file in loudness_db:
                analysis_data = loudness_db[abs_input_file]
                if args.verbose:
                    print("Info: Using pre-analyzed loudness data from log.")
            else:
                if isinstance(args.normalize, str) and args.verbose:
                    print(f"Info: File not found in log, running live analysis...")
                print("Running audio normalization analysis (Pass 1)...")
                analysis_data = run_loudnorm_analysis(input_file)
                if analysis_data:
                    print("Analysis complete.")
        
            if analysis_data and normalize_mode == 'add':
                try:
                    measured_i = analysis_data['i']; measured_tp = analysis_data['tp']
                    measured_lra = analysis_data['lra']; measured_thresh = analysis_data['thresh']
                    filter_string_for_complex = f"[0:a:0]loudnorm=I=-23:LRA=7:tp=-2:measured_I={measured_i}:measured_tp={measured_tp}:measured_LRA={measured_lra}:measured_thresh={measured_thresh}[a_norm]"
                    ffmpeg_cmd.extend(['-filter_complex', filter_string_for_complex])
                except KeyError:
                    print("Warning: Audio analysis data was incomplete. Will copy.", file=sys.stderr)
                    analysis_data = None # Mark as failed
                    is_normalize_enabled = False
            
            if not analysis_data and is_normalize_enabled:
                print("Warning: Audio normalization analysis failed. Falling back to copy.", file=sys.stderr)
                is_normalize_enabled = False # Disable it for this file

        # 4. Stream Mapping
        if args.filter_streams and len(files_to_process) == 1:
            if not all_streams: continue # get_stream_info failed earlier
            s_keep, s_rem = plan_stream_selection(all_streams)
            if not display_and_confirm_plan(s_keep, s_rem):
                print("Skipping file.")
                continue
            for stream in s_keep: ffmpeg_cmd.extend(['-map', f"0:{stream['index']}"])
            # Do not map any external subs if filtering
        
        else: 
            # New default auto-mapping logic
            if args.verbose:
                print("Info: Auto-mapping all streams.")
                
            ffmpeg_cmd.extend(['-map', '0:v?']) # Map all video
            
            if is_normalize_enabled and normalize_mode == 'add' and filter_string_for_complex:
                if args.verbose: print("Info: Mapping '[a_norm]' for new normalized track.")
                ffmpeg_cmd.extend(['-map', '[a_norm]']) # This becomes output:a:0
            
            ffmpeg_cmd.extend(['-map', '0:a?']) # Map all original audio
            ffmpeg_cmd.extend(['-map', '0:s?', '-map', '0:d?', '-map', '0:t?']) # Map all other streams
            
            # Now map all *external* subs we just added
            if external_sub_files:
                if args.verbose:
                    print(f"Info: Mapping {len(external_sub_files)} external subtitle stream(s).")
                
                internal_sub_count = len([s for s in all_streams if s.get('codec_type') == 'subtitle'])
                
                for i, sub_file in enumerate(external_sub_files):
                    current_input_index = i + 1 # +1 because 0 is the video
                    ffmpeg_cmd.extend([f'-map', f'{current_input_index}']) # Map all streams from this sub file
                    
                    # Add language metadata
                    lang_code = "eng" # Default
                    base_name, _ = os.path.splitext(os.path.basename(sub_file))
                    parts = base_name.split('.')
                    if len(parts) > 1 and len(parts[-1]) in [2, 3]: # e.g., .en.srt
                        lang_part = parts[-1]
                        if lang_part not in ['forced', 'sdh']: # common suffixes that aren't langs
                            lang_code = lang_part
                    
                    output_sub_index = internal_sub_count + i
                    ffmpeg_cmd.extend([f'-metadata:s:s:{output_sub_index}', f'language={lang_code}'])

        # --- END MODIFIED (v8.2.4) ---

        # --- MODIFIED: Reworked Codec Logic (v8.2.5) ---
        
        audio_normalized = False # Define here for summary

        # 1. VIDEO CODEC
        if is_transcode_op:
            print("\nMode: VAAPI Video Transcode")
            if is_avi:
                # Add the manual hwupload filter (goes AFTER -i)
                ffmpeg_cmd.extend(['-vf', 'format=nv12,hwupload'])
            ffmpeg_cmd.extend(['-c:v', 'hevc_vaapi', '-preset', args.preset, '-global_quality', str(args.quality)])
        else:
            print("Mode: Lossless Video Remux");
            ffmpeg_cmd.extend(['-c:v', 'copy'])

        # 2. AUDIO CODEC
        if is_normalize_enabled and analysis_data:
            # --- Normalization is ON and SUCCESSFUL ---
            if normalize_mode == 'add':
                # --- [A]dd Mode ---
                print("Info: Adding normalized AAC track as default, copying all other audio.")
                # This targets the first mapped audio stream (output:a:0, from [a_norm])
                ffmpeg_cmd.extend(['-c:a:0', 'aac', '-q:a:0', '4'])
                ffmpeg_cmd.extend(['-disposition:a:0', 'default'])
                
                # --- MODIFIED: Explicitly copy all other streams ---
                # This avoids the global -c:a copy conflict
                for i in range(len(audio_streams)):
                    output_stream_index = i + 1 # Starts at 1 (a:0 is the new one)
                    ffmpeg_cmd.extend([f'-c:a:{output_stream_index}', 'copy'])
                audio_normalized = True
            
            else: # --- [R]eplace Mode ---
                print("Info: Audio stream 0 will be normalized (EBU R128). Other audio streams re-encoded.")
                try:
                    measured_i = analysis_data['i']; measured_tp = analysis_data['tp']
                    measured_lra = analysis_data['lra']; measured_thresh = analysis_data['thresh']
                    filter_string = f"loudnorm=I=-23:LRA=7:tp=-2:measured_I={measured_i}:measured_tp={measured_tp}:measured_LRA={measured_lra}:measured_thresh={measured_thresh}"
                    
                    # This is the original, destructive logic
                    # It applies to output:a:0 (from input:a:0)
                    ffmpeg_cmd.extend([f'-c:a:0', 'aac', '-q:a:0', '4', f'-af:a:0', filter_string])
                    # It applies to output:a:1, output:a:2...
                    for i in range(1, len(audio_streams)):
                        ffmpeg_cmd.extend([f'-c:a:{i}', 'aac', '-q:a:1', '5', f'-af:a:{i}', 'anull'])
                    audio_normalized = True
                except KeyError:
                    print("Warning: Audio analysis data was incomplete. Falling back to copy.", file=sys.stderr)
                    audio_normalized = False
        
        # --- Fallback audio logic ---
        if not audio_normalized:
            if args.acodec:
                # User specified a global audio codec
                ffmpeg_cmd.extend(['-c:a', args.acodec])
                if args.abitrate: # Only add bitrate if acodec is also specified
                    ffmpeg_cmd.extend(['-b:a', args.abitrate])
            else:
                # This is the catch-all. If we aren't normalizing AND we
                # aren't re-encoding to a specific codec, copy all audio.
                # (This is safe, as -c:a:0... will override this if set)
                ffmpeg_cmd.extend(['-c:a', 'copy'])
                if args.verbose and normalize_mode != 'skip':
                    print("Info: Copying all audio streams.")

        # 3. SUBTITLE, CHAPTER, and OTHER STREAM LOGIC
        
        # --- MODIFIED: Always copy subtitles for MKV output ---
        # This handles both bitmap (PGS) and text (SRT, ASS)
        if args.verbose:
            print("Info: Copying all subtitle streams (text and bitmap).")
        ffmpeg_cmd.extend(['-c:s', 'copy'])
        
        # Always copy chapters and attachments
        if args.verbose:
            print("Info: Copying all chapter and attachment streams.")
        ffmpeg_cmd.extend(['-c:d', 'copy', '-c:t', 'copy'])
        
        # --- END MODIFIED (v8.2.5) ---
        
        # --- END Codec Logic ---

        ffmpeg_cmd.append(output_file) # Add output file path
        
        # --- Execute ---
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
            if chapter_file_for_this_run:
                 mkvpropedit_cmd = ['mkvpropedit', output_file, '--chapters', chapter_file_for_this_run]
                 print("\nMKVPropEdit command (Dry Run):")
                 print(' '.join(f'"{a}"' if ' ' in a else a for a in mkvpropedit_cmd))
        else:
            run_ffmpeg_command(
                ffmpeg_cmd,
                input_file,
                args.delete,
                audio_normalized=audio_normalized, # <--- MODIFIED
                total_frames=total_frames,
                permissions=permissions_to_apply,
                chapter_file_to_embed=chapter_file_for_this_run,
                verbose=args.verbose # <-- MODIFIED: Pass verbose flag
            )

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()