#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete

# --- Version History ---
__version__ = "3.8"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v3.8: Added a file size summary that displays the original and new file
      sizes, the space saved, and the percentage reduction after each
      successful operation.
v3.7: Added -D/--delete flag to delete the source file after a
      successful transcode.
v3.6: Fixed a crash (AttributeError) caused by a typo when checking the
      --skip-hevc argument. Changed 'args.skip-hevc' to 'args.skip_hevc'.
v3.5: Output filenames are now automatically sanitized. Parentheses are
      removed and spaces are replaced with periods.
v3.4: In batch mode, output files are now automatically renamed with a .CONV
      suffix before the extension to distinguish them from source files.
v3.3: Modified script to always print the current version number on execution
      as the first line of output, regardless of other flags.
v3.2: Fixed a crash when transcoding files with bitmap subtitles (e.g., PGS).
      The script now copies subtitle streams (-c:s copy).
v3.1: Added -H/--hvec flag to explicitly force HEVC output.
v3.0: Major feature release with batch processing.
"""

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')

# --- Helper Functions ---

def format_bytes(size_bytes):
    """Converts a byte value into a human-readable string (KB, MB, GB)."""
    if size_bytes is None or size_bytes == 0:
        return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return f"{s} {size_name[i]}"

def print_size_summary(original_bytes, new_bytes):
    """Calculates and prints a summary of the file size change."""
    if original_bytes is None or new_bytes is None:
        return

    print("\n--- File Size Summary ---")
    print(f"Original Size: {format_bytes(original_bytes)}")
    print(f"New Size     : {format_bytes(new_bytes)}")

    if original_bytes > 0:
        difference_bytes = original_bytes - new_bytes
        percentage = (difference_bytes / original_bytes) * 100
        
        if difference_bytes > 0:
            print(f"Space Saved  : {format_bytes(difference_bytes)} ({percentage:.2f}% reduction)")
        else:
            print(f"Size Increase: {format_bytes(abs(difference_bytes))} ({abs(percentage):.2f}% increase)")
    print("-------------------------")


def find_video_files(input_path, recursive):
    """Finds all video files in a given path."""
    video_files = []
    if recursive:
        for root, _, files in os.walk(input_path):
            for file in files:
                if file.lower().endswith(VIDEO_EXTENSIONS):
                    video_files.append(os.path.join(root, file))
    else:
        for file in os.listdir(input_path):
            if file.lower().endswith(VIDEO_EXTENSIONS):
                video_files.append(os.path.join(input_path, file))
    return video_files

def is_hevc(file_path):
    """Checks if the video codec of a file is HEVC."""
    if not os.path.exists(file_path):
        return False
    ffprobe_cmd = [
        'ffprobe', '-v', 'error', '-select_streams', 'v:0',
        '-show_entries', 'stream=codec_name', '-of',
        'default=noprint_wrappers=1:nokey=1', file_path
    ]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return 'hevc' in result.stdout.lower()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def print_ffmpeg_command(cmd):
    """Prints the command in a copy-pasteable format."""
    print("\nExecuting FFmpeg command (Dry Run):")
    cmd_str = ' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd)
    print(cmd_str)

def run_ffmpeg_command(cmd, source_file, delete_source):
    """Prints and executes the FFmpeg command, optionally deleting the source file."""
    print("\nExecuting FFmpeg command:")
    cmd_str = ' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd)
    print(cmd_str)
    
    original_size = os.path.getsize(source_file) if os.path.exists(source_file) else None

    print("\n------------------------- FFmpeg Output -------------------------")
    try:
        process = subprocess.run(cmd, check=True)
        print("-----------------------------------------------------------------")
        
        output_file = cmd[-1]
        print(f"\nSuccessfully created '{output_file}'.")
        
        new_size = os.path.getsize(output_file) if os.path.exists(output_file) else None
        print_size_summary(original_size, new_size)
        
        if delete_source:
            print(f"\nInfo: --delete flag is set. Deleting source file...")
            try:
                os.remove(source_file)
                print(f"Successfully deleted: {source_file}")
            except OSError as e:
                print(f"\nError: Could not delete source file '{source_file}'. Reason: {e}", file=sys.stderr)

    except FileNotFoundError:
        print("\nError: 'ffmpeg' not found. Is it installed and in your PATH?", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print("-----------------------------------------------------------------")
        print(f"\nError: FFmpeg failed with exit code {e.returncode}.", file=sys.stderr)
        sys.exit(1)

# --- Main Logic ---
def main():
    """Parses arguments and performs media operations."""
    print(f"hvec v{__version__}")

    if '-v' in sys.argv or '--version' in sys.argv:
        print(VERSION_HISTORY)
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="A tool to transcode or remux video files using Intel QSV.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Examples:
  # Transcode a file and delete the original upon success
  ,hvec -i "My Movie.mp4" -D

  # Transcode all videos in a folder and delete the originals
  ,hvec -i /path/to/videos/ -D
"""
    )
    # --- All Arguments Defined Here ---
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    parser.add_argument("-o", "--output", help="Output MKV file. If specified, name sanitization is skipped.")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete the original input file after a successful transcode.")
    parser.add_argument("--out-dir", help="Output directory for batch processing. Preserves source folder structure.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process files in subdirectories when -i is a directory.")
    parser.add_argument("-s", "--subs", help="(Optional) External subtitle file to embed (single file mode only).")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force output to be HEVC/H.265. Overrides --remux.")
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set QSV quality for video (1-51, lower is better). Default: 24.")
    parser.add_argument("-p", "--preset", type=str, default='medium',
                        choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'],
                        help="Set QSV encoding preset. Slower presets offer better compression. Default: medium.")
    parser.add_argument("--acodec", help="Re-encode audio to a specific codec (e.g., aac, ac3). Default: copy.")
    parser.add_argument("--abitrate", help="Set audio bitrate when re-encoding (e.g., 192k, 384k).")
    parser.add_argument("--skip-hevc", action="store_true", help="In batch mode, skip transcoding files that are already H.265/HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print the FFmpeg commands without executing them.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux instead of transcoding.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress most FFmpeg output. Overrides --less-noise.")
    parser.add_argument("--less-noise", action="store_true", help="Show progress updates only every 30 seconds.")
    parser.add_argument("-v", "--version", action="store_true", help="Show the version history and exit.")

    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    files_to_process = []
    if not os.path.exists(args.input):
        print(f"Error: Input path not found: '{args.input}'", file=sys.stderr)
        sys.exit(1)

    if os.path.isdir(args.input):
        print(f"\nInput is a directory. Scanning for video files...")
        files_to_process = find_video_files(args.input, args.recursive)
        print(f"Found {len(files_to_process)} video files to process.")
    else:
        files_to_process.append(args.input)

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        
        if args.skip_hevc and is_hevc(input_file):
            print("Video is already HEVC. Skipping.")
            continue

        # --- Determine Output Path ---
        output_file = ""
        if len(files_to_process) > 1: # Batch mode
            base_name, _ = os.path.splitext(os.path.basename(input_file))
            sanitized_base_name = base_name.replace('(', '').replace(')', '').replace(' ', '.')
            new_filename = sanitized_base_name + ".CONV.mkv"
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input)
                output_dir = os.path.join(args.out_dir, relative_path)
                if not os.path.exists(output_dir):
                    os.makedirs(output_dir)
                output_file = os.path.join(output_dir, new_filename)
            else:
                output_file = os.path.join(os.path.dirname(input_file), new_filename)
        else: # Single file mode
            if args.output:
                output_file = args.output
            else:
                base_name, _ = os.path.splitext(input_file)
                sanitized_base_name = base_name.replace('(', '').replace(')', '').replace(' ', '.')
                output_file = sanitized_base_name + ".mkv"
        
        ffmpeg_cmd = ['ffmpeg']
        if args.quiet:
            ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        elif args.less-noise:
            ffmpeg_cmd.extend(['-stats_period', '30'])
        ffmpeg_cmd.extend(['-hwaccel', 'qsv', '-i', input_file])
        if args.subs:
            if len(files_to_process) > 1:
                print("Warning: External subtitles (--subs) are only supported for single file processing. Ignoring.")
            else:
                if not os.path.exists(args.subs):
                    print(f"Error: Subtitle file not found: '{args.subs}'", file=sys.stderr)
                    continue
                ffmpeg_cmd.extend(['-i', args.subs])
        if args.subs and len(files_to_process) == 1:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '1:s:0'])
        else:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '0:s?'])
        if args.remux and not args.hvec:
            print("Mode: Lossless Remux")
            ffmpeg_cmd.extend(['-c', 'copy'])
        else:
            if args.hvec:
                print("\nMode: QSV Transcode (Forced by -H/--hvec flag)")
            else:
                print("\nMode: QSV Transcode")
            ffmpeg_cmd.extend(['-c:v', 'hevc_qsv', '-preset', args.preset, '-global_quality', str(args.quality)])
            if args.acodec:
                print(f"Re-encoding audio to {args.acodec.upper()}")
                ffmpeg_cmd.extend(['-c:a', args.acodec])
                if args.abitrate:
                    ffmpeg_cmd.extend(['-b:a', args.abitrate])
            else:
                ffmpeg_cmd.extend(['-c:a', 'copy'])
            ffmpeg_cmd.extend(['-c:s', 'copy'])
        ffmpeg_cmd.append(output_file)
        
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
            if args.delete:
                print(f"Info: Source file '{input_file}' would be deleted upon success.")
        else:
            run_ffmpeg_command(ffmpeg_cmd, input_file, args.delete)

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()