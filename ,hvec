#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete
import re
import shutil
from tqdm import tqdm

# --- Version History ---
__version__ = "6.1"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v6.1: Fixed a bug in the file size summary where values would not appear.
      - Replaced format_bytes and print_size_summary functions with more
        robust versions that handle all cases correctly.
      - Summary now shows Original, New, and Difference for better clarity.
v6.0: Rebuilt the progress bar feature from the ground up, starting from the
      stable v5.8 baseline. This version implements the definitive progress
      bar using the best tools discovered during previous debugging:
      - `mediainfo` is the primary method for getting a fast, accurate
        frame count, with a fallback to `ffprobe`.
      - `tqdm` is used to display a clean, Python-native progress bar.
      - Incorporates critical fixes for hardware hangs (using VAAPI), I/O
        buffering (using `stdbuf`), and overwrite stalls.
v5.8: Added a handler for Ctrl+C to exit gracefully.
"""
# --- MODIFICATION END ---

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')

# --- Helper Functions ---
def get_total_frames(file_path):
    """Gets total frames quickly using mediainfo (preferred) or falls back."""
    # Method 1: mediainfo (fast and most reliable)
    if shutil.which('mediainfo'):
        cmd = ['mediainfo', '--Inform=Video;%FrameCount%', file_path]
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            return int(result.stdout.strip())
        except (subprocess.CalledProcessError, ValueError, FileNotFoundError):
            pass # Fall through to the next method

    # Method 2: ffprobe (fast estimate, as a fallback)
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=duration,avg_frame_rate', '-of', 'json', file_path]
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        data = json.loads(result.stdout)['streams'][0]
        if 'duration' not in data or 'avg_frame_rate' not in data: return None
        duration, fr_str = float(data['duration']), data['avg_frame_rate']
        if '/' in fr_str:
            n, d = map(int, fr_str.split('/')); frame_rate = n / d if d != 0 else 0
        else: frame_rate = float(fr_str)
        if duration <= 0 or frame_rate <= 0: return None
        return int(duration * frame_rate)
    except Exception:
        return None

def get_stream_info(file_path):
    """Uses ffprobe to get structured information about all streams in a file."""
    ffprobe_cmd = ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', file_path]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return json.loads(result.stdout).get('streams', [])
    except Exception:
        print(f"Error: Could not get stream information from '{file_path}'.", file=sys.stderr)
        return None

def plan_stream_selection(streams):
    streams_to_keep, streams_to_remove = [], []
    for s in streams:
        keep = False; stype = s.get('codec_type'); tags = s.get('tags', {}); lang = tags.get('language', 'und').lower(); title = s.get('title', '').lower()
        if stype == 'video' or (stype == 'audio' and (lang == 'eng' or 'commentary' in title or 'director' in title)) or (stype == 'subtitle' and lang == 'eng'): keep = True
        if keep: streams_to_keep.append(s)
        else: streams_to_remove.append(s)
    return streams_to_keep, streams_to_remove

def display_and_confirm_plan(s_keep, s_rem):
    print("\n--- Stream Selection Plan ---\nKEPT:"); [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_keep]
    print("\nREMOVED:"); [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_rem]
    try: return input("Proceed? [y/N]: ").lower().strip() == 'y'
    except KeyboardInterrupt: return False

def format_size(size_bytes):
    """Converts a size in bytes to a human-readable string using binary prefixes."""
    if size_bytes is None or not isinstance(size_bytes, (int, float)) or size_bytes < 0:
        return "N/A"
    if size_bytes == 0:
        return "0 B"
    size_name = ("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB")
    try:
        i = int(math.floor(math.log(size_bytes, 1024)))
        if i >= len(size_name):
            i = len(size_name) - 1
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"
    except (ValueError, TypeError):
        return "N/A"

def print_size_summary(original_size_bytes, new_size_bytes):
    """Prints a formatted summary of the file size change."""
    print("\n--- File Size Summary ---")
    original_size_str = format_size(original_size_bytes)
    new_size_str = format_size(new_size_bytes)
    
    print(f"Original:   {original_size_str}")
    print(f"New:        {new_size_str}")

    if original_size_bytes is not None and new_size_bytes is not None and original_size_bytes > 0:
        difference_bytes = new_size_bytes - original_size_bytes
        percentage_change = (difference_bytes / original_size_bytes) * 100
        change_type = "increase" if difference_bytes >= 0 else "decrease"
        difference_str = format_size(abs(difference_bytes))
        
        print(f"Difference: {difference_str} ({abs(percentage_change):.2f}% {change_type})")
    else:
        print("Difference: N/A")
        
    print("-------------------------")

def find_video_files(p, r):
    vids = [];
    if r: [vids.extend([os.path.join(root, f) for f in files if f.lower().endswith(VIDEO_EXTENSIONS)]) for root, _, files in os.walk(p)]
    else: vids.extend([os.path.join(p, f) for f in os.listdir(p) if f.lower().endswith(VIDEO_EXTENSIONS)])
    return vids

def is_hevc(f):
    if not os.path.exists(f): return False
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=codec_name', '-of', 'default=noprint_wrappers=1:nokey=1', f]
    try: return 'hevc' in subprocess.run(cmd, check=True, capture_output=True, text=True).stdout.lower()
    except Exception: return False

def print_ffmpeg_command(cmd): print("\nExecuting FFmpeg command (Dry Run):"); print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))

def run_ffmpeg_command(cmd, source_file, delete_source, total_frames=None):
    """Executes FFmpeg, showing a progress bar, and handling output."""
    print("\nExecuting FFmpeg command:"); print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))
    output_file = cmd[-1]
    original_size_bytes = os.path.getsize(source_file) if os.path.exists(source_file) else None
    
    # If progress flags aren't in the command, run simply.
    if "-progress" not in cmd:
        try:
            subprocess.run(cmd, check=True)
        except (subprocess.CalledProcessError, KeyboardInterrupt):
            print("\nOperation failed or was cancelled.", file=sys.stderr); sys.exit(1)
    else:
        # Run with a tqdm progress bar (determinate or indeterminate).
        if total_frames is None:
            print("\nWarning: Could not get total frames. Progress bar will not show percentage or ETA.")
        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8')
            with tqdm(total=total_frames, unit='frame', dynamic_ncols=True, desc="Transcoding") as pbar:
                for line in process.stdout:
                    if line.strip().startswith("frame="):
                        current_frame = int(line.strip().split("=")[1])
                        pbar.update(max(0, current_frame - pbar.n))
            stderr_output = process.stderr.read(); process.wait()
            if process.returncode != 0:
                print(f"\n--- FFmpeg Error ---\n{stderr_output}\n--------------------")
                sys.exit(1)
        except (FileNotFoundError, KeyboardInterrupt) as e:
            print(f"\nError: A required command was not found (e.g., ffmpeg, stdbuf)." if isinstance(e, FileNotFoundError) else "\nCancelled.", file=sys.stderr)
            if 'process' in locals(): process.terminate()
            sys.exit(1)

    # Post-run safety checks
    if not os.path.exists(output_file): print(f"\nError: Output file not created.", file=sys.stderr); sys.exit(1)
    try:
        new_size_bytes = os.path.getsize(output_file)
        subprocess.run(['ffprobe', '-v', 'error', output_file], check=True, capture_output=True)
    except Exception: print(f"\nError: Output file appears to be invalid.", file=sys.stderr); sys.exit(1)
    
    print(f"\nSuccessfully created and verified '{output_file}'.")
    print_size_summary(original_size_bytes, new_size_bytes)
    
    if delete_source:
        print(f"\nInfo: --delete flag is set. Deleting source file...")
        try:
            os.remove(source_file); print(f"Successfully deleted: {source_file}")
        except OSError as e:
            print(f"\nError: Could not delete source file '{source_file}'. Reason: {e}", file=sys.stderr)

# --- Main Logic ---
def main():
    if '-v' in sys.argv or '--version' in sys.argv: print(VERSION_HISTORY); sys.exit(0)
    parser = argparse.ArgumentParser(description="A tool to transcode or remux files using Intel VAAPI.", formatter_class=argparse.RawTextHelpFormatter, epilog="Examples:\n  ,hvec -i \"My Movie.mkv\" -k\n  ,hvec -i /videos/ -D -k -R")
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    parser.add_argument("-o", "--output", help="Output MKV file.")
    parser.add_argument("-k", "--filter-streams", action="store_true", help="Interactively filter streams.")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete original file after success.")
    parser.add_argument("--out-dir", help="Output directory for batch processing.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process subdirectories.")
    parser.add_argument("-s", "--subs", nargs='+', help="External subtitle files to embed.")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force HEVC output.")
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set encoding quality (1-51 for VAAPI).")
    parser.add_argument("-p", "--preset", type=str, default='medium', choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'], help="Set encoding preset.")
    parser.add_argument("--acodec", help="Re-encode audio codec.")
    parser.add_argument("--abitrate", help="Set audio bitrate.")
    parser.add_argument("--skip-hevc", action="store_true", help="Skip files that are already HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print commands without executing.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress FFmpeg output.")
    parser.add_argument("-v", "--version", action="store_true", help="Show version history.")
    
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    print(f",hvec v{__version__}")

    if not os.path.exists(args.input): print(f"Error: Input not found", file=sys.stderr); sys.exit(1)
    files_to_process = find_video_files(args.input, args.recursive) if os.path.isdir(args.input) else [args.input]

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        
        # This is the original, correct logic from v5.8
        if args.skip_hevc and is_hevc(input_file):
            print("Video is already HEVC. Skipping.")
            continue

        def generate_output_filename(base, is_remux):
            sanitized = base.replace('(', '').replace(')', '').replace(' ', '.').replace('_', '.')
            suffix = ".REMUX" if is_remux else ".CONV"
            return f"{sanitized}{suffix}.mkv" if not sanitized.endswith(suffix) else f"{sanitized}.mkv"

        if args.output and len(files_to_process) == 1: output_file = args.output
        else:
            base, _ = os.path.splitext(os.path.basename(input_file))
            new_filename = generate_output_filename(base, args.remux)
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input if os.path.isdir(args.input) else os.path.dirname(args.input))
                output_dir = os.path.join(args.out_dir, relative_path); os.makedirs(output_dir, exist_ok=True)
                output_file = os.path.join(output_dir, new_filename)
            else: output_file = os.path.join(os.path.dirname(input_file), new_filename)
        
        if os.path.exists(output_file) and not args.dry_run:
            try:
                if input(f"Output '{os.path.basename(output_file)}' exists. Overwrite? [y/N]: ").lower().strip() != 'y':
                    print("Skipping."); continue
            except KeyboardInterrupt: print("\nCancelled."); sys.exit(1)
        
        is_remux_op = args.remux and not args.hvec
        total_frames = None
        use_progress_bar = not (is_remux_op or args.quiet or args.dry_run)
        
        if use_progress_bar:
            total_frames = get_total_frames(input_file)

        ffmpeg_cmd = ['ffmpeg', '-y']
        
        if use_progress_bar:
            if sys.platform != "win32": ffmpeg_cmd = ['stdbuf', '-o0'] + ffmpeg_cmd
            ffmpeg_cmd.extend(['-progress', '-', '-nostats'])
        elif args.quiet:
            ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        else:
            ffmpeg_cmd.extend(['-v', 'error', '-stats'])
        
        # Use VAAPI, the proven fix for your hardware
        if not is_remux_op:
            ffmpeg_cmd.extend(['-hwaccel', 'vaapi', '-hwaccel_output_format', 'vaapi'])
        
        ffmpeg_cmd.extend(['-i', input_file])
        
        if args.filter_streams:
            all_streams = get_stream_info(input_file)
            if all_streams is None: continue
            s_keep, s_rem = plan_stream_selection(all_streams)
            if not display_and_confirm_plan(s_keep, s_rem): print("Skipping file."); continue
            for stream in s_keep: ffmpeg_cmd.extend(['-map', f"0:{stream['index']}"])
        elif args.subs and len(files_to_process) == 1:
            for sub_file in args.subs:
                if os.path.exists(sub_file): ffmpeg_cmd.extend(['-i', sub_file])
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?'])
            for j in range(len(args.subs)): ffmpeg_cmd.extend(['-map', f'{j+1}:s:0', f'-metadata:s:s:{j}', 'language=eng'])
        else:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '0:s?'])

        if is_remux_op:
            print("Mode: Lossless Remux"); ffmpeg_cmd.extend(['-c', 'copy'])
            if args.subs: ffmpeg_cmd.extend(['-c:s', 'srt'])
        else:
            print("\nMode: VAAPI Transcode")
            # Use VAAPI codec, the proven fix
            ffmpeg_cmd.extend(['-c:v', 'hevc_vaapi', '-preset', args.preset, '-global_quality', str(args.quality)])
            ffmpeg_cmd.extend(['-c:a', args.acodec] if args.acodec else ['-c:a', 'copy'])
            if args.acodec and args.abitrate: ffmpeg_cmd.extend(['-b:a', args.abitrate])
            ffmpeg_cmd.extend(['-c:s', 'srt'] if args.subs else ['-c:s', 'copy'])
            
        ffmpeg_cmd.append(output_file)
        
        if args.dry_run: 
            print_ffmpeg_command(ffmpeg_cmd)
        else: 
            run_ffmpeg_command(ffmpeg_cmd, input_file, args.delete, total_frames=total_frames)

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()