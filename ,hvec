#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete
import re
import shutil
from tqdm import tqdm
import grp
from typing import Dict, Any, List
import csv
import time

# --- Version History ---
__version__ = "8.1.7"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v8.1.7  fix(ffmpeg): Map *all* streams, not just v/a/s
        
        - The script was only mapping video, audio, and
          subtitles (`-map 0:v -map 0:a? -map 0:s?`).
        - This was incorrect, as it dropped embedded chapters,
          attachments, and other metadata streams.
        - The logic is now simplified to use `-map 0`, which
          selects *all* streams from the main input file.
        - This ensures embedded chapters are preserved
          during remuxing, as requested by the user.
        - The `-s` flag logic is now smarter and maps
          external subs to the *next* available index.

v8.1.6  fix(ffmpeg): *Actually* fix contradictory audio codec/filter logic
v8.1.5  fix(ffmpeg): (Failed attempt) Correct contradictory audio logic
v8.1.4  feat(normalize): Add fallback search for default log file
v8.1.3  fix(main): Add missing 'import time'
v8.1.2  feat(main): Re-enable argcomplete
v8.1.1  fix(subs): Use absolute path for sidecar subtitle scan
v8.1.0  feat(log): Add -V/--verbose flag for detailed output
v8.0.9  feat(subs): Auto-detect and embed sidecar subtitles
v8.0.8  fix(remux): Use -c:s copy when in remux mode
v8.0.5  fix(main): Correct indentation on 'skip_hevc' continue
        ...
"""
# --- MODIFICATION END ---

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')
SUBTITLE_EXTENSIONS = ('.srt', '.ass', '.sub')

DEFAULT_LOG_BASENAME = 'audit_loudness.csv'
DEFAULT_LOG_DIR = os.path.expanduser('~/.hvec')
DEFAULT_LOG_PATH = os.path.join(DEFAULT_LOG_DIR, DEFAULT_LOG_BASENAME)
CWD_LOG_PATH = os.path.abspath(DEFAULT_LOG_BASENAME)

# --- Helper Functions ---
def get_total_frames(file_path):
    """Gets total frames quickly using mediainfo (preferred) or falls back."""
    if shutil.which('mediainfo'):
        cmd = ['mediainfo', '--Inform=Video;%FrameCount%', file_path]
        try:
            result = subprocess.run(cmd, check=True, capture_output=True, text=True)
            return int(result.stdout.strip())
        except (subprocess.CalledProcessError, ValueError, FileNotFoundError):
            pass
  
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=duration,avg_frame_rate', '-of', 'json', file_path]
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        data = json.loads(result.stdout)['streams'][0]
        if 'duration' not in data or 'avg_frame_rate' not in data: return None
        duration, fr_str = float(data['duration']), data['avg_frame_rate']
        if '/' in fr_str:
            n, d = map(int, fr_str.split('/'));
            frame_rate = n / d if d != 0 else 0
        else: frame_rate = float(fr_str)
        if duration <= 0 or frame_rate <= 0: return None
        return int(duration * frame_rate)
    except Exception: return None

def get_stream_info(file_path):
    """Uses ffprobe to get structured information about all streams in a file."""
    ffprobe_cmd = ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', file_path]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return json.loads(result.stdout).get('streams', [])
    except Exception:
        print(f"Error: Could not get stream information from '{file_path}'.", file=sys.stderr);
        return None

def plan_stream_selection(streams):
    streams_to_keep, streams_to_remove = [], []
    for s in streams:
        keep = False;
        stype = s.get('codec_type'); tags = s.get('tags', {}); lang = tags.get('language', 'und').lower();
        title = s.get('title', '').lower()
        if stype == 'video' or (stype == 'audio' and (lang == 'eng' or 'commentary' in title or 'director' in title)) or (stype == 'subtitle' and lang == 'eng'): keep = True
        if keep: streams_to_keep.append(s)
        else: streams_to_remove.append(s)
    return streams_to_keep, streams_to_remove

def display_and_confirm_plan(s_keep, s_rem):
    print("\n--- Stream Selection Plan ---\nKEPT:");
    [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_keep]
    print("\nREMOVED:");
    [print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})") for s in s_rem]
    try: return input("Proceed? [y/N]: ").lower().strip() == 'y'
    except KeyboardInterrupt: return False

def format_size(size_bytes):
    """Converts a size in bytes to a human-readable string using binary prefixes."""
    if size_bytes is None or not isinstance(size_bytes, (int, float)) or size_bytes < 0: return "N/A"
    if size_bytes == 0: return "0 B"
    size_name = ("B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB")
    try:
        i = int(math.floor(math.log(size_bytes, 1024)));
        i = min(i, len(size_name) - 1)
        p = math.pow(1024, i);
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"
    except (ValueError, TypeError): return "N/A"

def print_size_summary(original_size_bytes, new_size_bytes, audio_normalized=False):
    """Prints a formatted summary of the file size change."""
    print("\n--- File Size Summary ---")
    original_size_str = format_size(original_size_bytes);
    new_size_str = format_size(new_size_bytes)
    print(f"Original:   {original_size_str}");
    print(f"New:         {new_size_str}")
    if original_size_bytes is not None and new_size_bytes is not None and original_size_bytes > 0:
        difference_bytes = new_size_bytes - original_size_bytes;
        percentage_change = (difference_bytes / original_size_bytes) * 100
        change_type = "increase" if difference_bytes >= 0 else "decrease";
        difference_str = format_size(abs(difference_bytes))
        print(f"Difference: {difference_str} ({abs(percentage_change):.2f}% {change_type})")
    else: print("Difference: N/A")
    
    if audio_normalized:
        print("Audio:      Normalized (EBU R128)")
    
    print("-------------------------")

def find_video_files(p, r):
    vids = [];
    if r: [vids.extend([os.path.join(root, f) for f in files if f.lower().endswith(VIDEO_EXTENSIONS)]) for root, _, files in os.walk(p)]
    else: vids.extend([os.path.join(p, f) for f in os.listdir(p) if f.lower().endswith(VIDEO_EXTENSIONS)])
    return vids

def is_hevc(f):
    if not os.path.exists(f): return False
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=codec_name', '-of', 'default=noprint_wrappers=1:nokey=1', f]
    try: return 'hevc' in subprocess.run(cmd, check=True, capture_output=True, text=True).stdout.lower()
    except Exception: return False

def print_ffmpeg_command(cmd):
    """Prints the FFmpeg command for dry-run mode."""
    print("\nExecuting FFmpeg command (Dry Run):")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))

# --- MODIFIED: Using fast ebur128 analysis (v8.0.0) ---
def run_loudnorm_analysis(input_file: str) -> Dict[str, float] or None:
    """
    Runs the FFmpeg ebur128 analysis on a single file.
    This is much faster than the loudnorm filter.
    """
    start_time = time.time() # <-- This line needs 'import time'
    cmd = [
        'ffmpeg', '-nostdin', '-i', input_file,
        '-threads', '0',  # Use all available threads
        '-map', '0:a:0',  # Analyze the first audio stream
        '-af', 'ebur128=peak=true', # Use the ebur128 filter
        '-f', 'null', '-'
    ]
    
    try:
        # The ebur128 filter writes all its output to stderr.
        result = subprocess.run(cmd, capture_output=True, text=True, encoding='utf-8', timeout=1200)
        
        stderr_output = result.stderr
        
        if not stderr_output:
            print("Error: No output from ffmpeg analysis.", file=sys.stderr)
            return None

        # --- Regex patterns to find the 4 values ---
        patterns = {
            'i':      re.compile(r"Integrated loudness:\s+I:\s*(-?[\d\.]+)\s+LUFS"),
            'thresh': re.compile(r"Integrated loudness:\s+I:.*?\s+Threshold:\s*(-?[\d\.]+)\s+LUFS"),
            'lra':    re.compile(r"Loudness range:\s+LRA:\s*(-?[\d\.]+)\s+LU"),
            'tp':     re.compile(r"True peak:\s+Peak:\s*(-?[\d\.]+)\s+dBFS")
        }
        
        loudness_data = {}
        missing_keys = []
        
        for key, pattern in patterns.items():
            match = pattern.search(stderr_output)
            if match:
                loudness_data[key] = float(match.group(1))
            else:
                missing_keys.append(key)

        if missing_keys:
            if "Stream map '0:a:0' matches no streams" in stderr_output:
                return None # Return None, main loop will print warning
            else:
                print(f"Error: Could not parse ebur128 output. Missing: {', '.join(missing_keys)}", file=sys.stderr)
                return None

        return loudness_data
        
    except subprocess.TimeoutExpired:
        print("Error: Audio analysis process timed out (20 minutes)", file=sys.stderr)
        return None
    except FileNotFoundError:
        print("Error: ffmpeg command not found in PATH", file=sys.stderr)
        return None
    except Exception as e:
        print(f"\nAn unexpected error occurred during audio analysis: {e}", file=sys.stderr)
        return None
# --- END MODIFIED ---

def embed_chapters_mkvpropedit(chapter_file, output_file):
    """Embeds chapters into an existing MKV file using mkvpropedit."""
    if not shutil.which('mkvpropedit'):
        print("\nError: 'mkvpropedit' command not found. Please install MKVToolNix.", file=sys.stderr)
        return False
    if not os.path.exists(chapter_file):
        print(f"\nError: Chapter file not found at '{chapter_file}'.", file=sys.stderr)
        return False
    if not os.path.exists(output_file):
        print(f"\nError: Output MKV file '{output_file}' not found for chapter embedding.", file=sys.stderr)
        return False

    mkvpropedit_cmd = ['mkvpropedit', output_file, '--chapters', chapter_file]
    print("\nExecuting mkvpropedit command:")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in mkvpropedit_cmd))

    try:
        # Capture output to check for errors/warnings
        result = subprocess.run(mkvpropedit_cmd, check=True, capture_output=True, text=True)
        # mkvpropedit often prints progress or confirmations to stdout/stderr even on success
        if result.stdout: print("mkvpropedit output:", result.stdout)
        if result.stderr: print("mkvpropedit errors/warnings:", result.stderr)
        print(f"Successfully embedded chapters into '{os.path.basename(output_file)}'.")
        return True
    except subprocess.CalledProcessError as e:
        print(f"\n--- mkvpropedit Error ---", file=sys.stderr)
        print(f"Command failed with exit code {e.returncode}", file=sys.stderr)
        if e.stdout: print("stdout:", e.stdout, file=sys.stderr)
        if e.stderr: print("stderr:", e.stderr, file=sys.stderr)
        print(f"-------------------------", file=sys.stderr)
        return False
    except Exception as e:
        print(f"\nAn unexpected error occurred running mkvpropedit: {e}", file=sys.stderr)
        return False

# --- MODIFIED: Added args.verbose to signature (v8.1.0) ---
def run_ffmpeg_command(cmd, source_file, delete_source, audio_normalized=False, total_frames=None, permissions=None, chapter_file_to_embed=None, verbose=False):
    """Executes FFmpeg, shows progress, verifies output, and optionally embeds chapters."""
    print("\nExecuting FFmpeg command:")
    print(' '.join(f'"{a}"' if ' ' in a else a for a in cmd))
    output_file = cmd[-1]
    original_size_bytes = os.path.getsize(source_file) if os.path.exists(source_file) else None
    
    # --- FFmpeg Execution ---
    ffmpeg_success = False
    try:
        if "-progress" not in cmd:
            subprocess.run(cmd, check=True)
        else:
            if total_frames is None: print("\nWarning: Could not get total frames. Progress bar indeterminate.")
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8')
            with tqdm(total=total_frames, unit='frame', dynamic_ncols=True, desc="FFmpeg") as pbar:
                for line in process.stdout:
                    if line.strip().startswith("frame="):
                        current_frame = int(line.strip().split("=")[1]); pbar.update(max(0, current_frame - pbar.n))
            stderr_output = process.stderr.read(); process.wait()
            if process.returncode != 0: raise subprocess.CalledProcessError(process.returncode, cmd, stderr=stderr_output)
        ffmpeg_success = True
    except (subprocess.CalledProcessError, FileNotFoundError, KeyboardInterrupt) as e:
        if isinstance(e, subprocess.CalledProcessError): print(f"\n--- FFmpeg Error ---\n{e.stderr}\n--------------------", file=sys.stderr)
        elif isinstance(e, FileNotFoundError): print("\nError: Required command not found (ffmpeg/stdbuf).", file=sys.stderr)
        else: print("\nCancelled.", file=sys.stderr)
        if 'process' in locals(): process.terminate()
        sys.exit(1) # Exit immediately on FFmpeg failure

    # --- Post-FFmpeg Verification ---
    if not ffmpeg_success or not os.path.exists(output_file):
        print(f"\nError: FFmpeg failed or output file '{output_file}' not created.", file=sys.stderr);
        sys.exit(1)
    try:
        new_size_bytes = os.path.getsize(output_file)
        subprocess.run(['ffprobe', '-v', 'error', output_file], check=True, capture_output=True)
    except Exception:
        print(f"\nError: Output file '{output_file}' appears invalid after FFmpeg.", file=sys.stderr);
        sys.exit(1)
    
    print(f"\nSuccessfully created and verified FFmpeg output '{output_file}'.")
    
    # --- Chapter Embedding (NEW STEP) ---
    chapters_embedded_successfully = True # Assume success if not requested
    if chapter_file_to_embed:
        chapters_embedded_successfully = embed_chapters_mkvpropedit(chapter_file_to_embed, output_file)
        if not chapters_embedded_successfully:
            print(f"\nError: Failed to embed chapters using mkvpropedit. Output file '{output_file}' may be incomplete.", file=sys.stderr)
            # Decide if you want to exit here or continue. For now, we continue but warn.
            # sys.exit(1)
    # --- END Chapter Embedding ---

    # --- Permissions ---
    if permissions:
        try:
            os.chown(output_file, permissions['uid'], permissions['gid']);
            os.chmod(output_file, permissions['mode'])
            # --- MODIFIED: Added verbose check (v8.1.0) ---
            if verbose:
                print(f"Info: Applied permissions to '{os.path.basename(output_file)}'.")
        except OSError as e: print(f"\nWarning: Could not set permissions. Reason: {e}", file=sys.stderr)

    print_size_summary(original_size_bytes, new_size_bytes, audio_normalized=audio_normalized)
    
    # --- Delete Source ---
    # Only delete if BOTH FFmpeg AND chapter embedding (if requested) were successful
    if delete_source and ffmpeg_success and chapters_embedded_successfully:
        print(f"\nInfo: --delete flag set. Deleting source file...")
        try:
            os.remove(source_file);
            print(f"Successfully deleted: {source_file}")
        except OSError as e: print(f"\nError: Could not delete source '{source_file}'. Reason: {e}", file=sys.stderr)
    elif delete_source:
         print(f"\nWarning: --delete flag ignored because chapter embedding failed.")

# --- MODIFIED: Added args.verbose to signature (v8.1.0) ---
def load_loudness_db(log_file: str, verbose=False) -> Dict[str, Dict[str, float]]:
    """
    Reads a CSV loudness audit log file and returns a
    dictionary mapping file paths to their normalization data.
    """
    db = {}
    if not os.path.exists(log_file):
        print(f"Warning: Loudness log not found at '{log_file}'. Will run analysis.", file=sys.stderr)
        return db

    # --- MODIFIED: Added verbose check (v8.1.0) ---
    if verbose:
        print(f"Info: Loading loudness database from '{os.path.basename(log_file)}'...")
    try:
        with open(log_file, 'r', encoding='utf-8', newline='') as f:
            # Use DictReader to read the log by header name
            reader = csv.DictReader(f)
            for row in reader:
                try:
                    if row.get('Status') == 'SUCCESS':
                        file_path = row.get('File', '').strip()
                        if not file_path:
                            continue
                            
                        # Keys must match what run_loudnorm_analysis returns
                        data = {
                            'i': float(row['CurrentLoudness']),
                            'tp': float(row['MeasuredTP']),
                            'lra': float(row['MeasuredLRA']),
                            'thresh': float(row['MeasuredThresh'])
                        }
                        db[file_path] = data
                except (ValueError, KeyError, TypeError, AttributeError):
                    # Ignore malformed or non-SUCCESS lines
                    pass
    except Exception as e:
        print(f"Error: Could not read loudness log '{log_file}': {e}", file=sys.stderr)
    
    # --- MODIFIED: Added verbose check (v8.1.0) ---
    if verbose:
        print(f"Info: Loaded {len(db)} pre-analyzed entries.")
    return db
# --- END MODIFIED ---


# --- Main Logic ---
def main():
    print(f",hvec v{__version__}") # Print current version first

    # --- Argument Parser ---
    parser = argparse.ArgumentParser(description="A tool to transcode or remux files using Intel VAAPI.", formatter_class=argparse.RawTextHelpFormatter, epilog="Examples:\n  ,hvec -i \"My Movie.mkv\" -k\n  ,hvec -i /videos/ -D -k -R\n  ,hvec -i movie.mp4 -r -C chapters.txt\n  ,hvec -i movie.mkv -N /path/to/loudness_audit.csv") # <-- MODIFIED Example
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    parser.add_argument("-o", "--output", help="Output MKV file (single file mode only).")
    parser.add_argument("-k", "--filter-streams", action="store_true", help="Interactively filter streams (single file mode only).")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete original file after success.")
    parser.add_argument("--out-dir", help="Output directory for batch processing.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process subdirectories.")
    parser.add_argument("-C", "--chapters", help="External chapter file (TXT/OGM or XML) to embed (requires MKVToolNix).")
    parser.add_argument("-s", "--subs", nargs='+', help="External subtitle files to embed (single file mode only).")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force HEVC output (overrides --remux).")
    
    # --- MODIFIED: -N now optionally takes a value (v7.8) ---
    parser.add_argument(
        "-N", "--normalize", 
        nargs='?', 
        const=True, 
        default=None, 
        help="Normalize audio to EBU R128 (-23 LUFS).\n"
             "Optionally provide a path to a loudness_audit.csv file \n" # <-- MODIFIED Example
             "to skip analysis and use pre-scanned values."
    )
    # --- END MODIFIED ---
    
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set VAAPI quality (1-51).")
    parser.add_argument("-p", "--preset", type=str, default='medium', choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'], help="Set encoding preset.")
    parser.add_argument("--acodec", help="Re-encode audio codec (e.g., 'aac', 'ac3'). Default: 'copy'.")
    parser.add_argument("--abitrate", help="Set audio bitrate (e.g., '192k', '384k').")
    parser.add_argument("--skip-hevc", action="store_true", help="Skip files that are already HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print commands without executing.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux (instead of transcode).")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress FFmpeg output.")
    parser.add_argument("-v", "--version", action="store_true", help="Show version history and exit.")
    
    # --- MODIFIED: Added verbose flag (v8.1.0) ---
    parser.add_argument("-V", "--verbose", action="store_true", help="Print detailed information during processing.")
    
    # --- MODIFIED: Added back argcomplete (v8.1.2) ---
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    # --- END MODIFIED ---
    
    # --- MODIFIED: Added verbose check (v8.1.0) ---
    if args.verbose:
        print("Info: Verbose mode enabled.")
    
    # --- MODIFIED: Corrected indentation (v8.0.2) ---
    if args.version:
        print(VERSION_HISTORY)
        sys.exit(0) # Handle --version flag
    # --- END MODIFIED ---

    # --- MODIFIED: Corrected indentation (v8.0.3) ---
    if not os.path.exists(args.input):
        print(f"Error: Input path not found: {args.input}", file=sys.stderr);
        sys.exit(1)
    # --- END MODIFIED ---
    
    # --- MODIFIED: Load Loudness DB (v8.1.4) ---
    loudness_db = {}
    is_normalize_enabled = args.normalize is not None
    analysis_data = None # <-- MODIFIED: Define analysis_data up here
    
    if isinstance(args.normalize, str):
        # Path provided, e.g., -N /path/to/log.csv
        if args.verbose:
            print(f"Info: User specified loudness log: {args.normalize}")
        loudness_db = load_loudness_db(args.normalize, args.verbose)
    
    elif is_normalize_enabled:
        # No path provided, e.g., -N
        # Check CWD first
        if os.path.exists(CWD_LOG_PATH):
            if args.verbose:
                print(f"Info: Found loudness log in CWD: {CWD_LOG_PATH}")
            loudness_db = load_loudness_db(CWD_LOG_PATH, args.verbose)
        # If not in CWD, check default ~/.hvec path
        elif os.path.exists(DEFAULT_LOG_PATH):
            if args.verbose:
                print(f"Info: Found loudness log in default path: {DEFAULT_LOG_PATH}")
            loudness_db = load_loudness_db(DEFAULT_LOG_PATH, args.verbose)
        else:
            if args.verbose:
                print(f"Info: No loudness log found in CWD or default path. Will run live analysis.")
    # --- END MODIFIED ---
    
    # --- File Processing Loop ---
    files_to_process = find_video_files(args.input, args.recursive) if os.path.isdir(args.input) else [args.input]
    
    # --- MODIFIED: Corrected indentation (v8.0.4) ---
    if not files_to_process:
        print("No video files found to process.")
        sys.exit(0)
    # --- END MODIFIED ---

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        
        # --- Chapter File Handling ---
        # Store chapter file path separately, disable for batch unless explicitly handled later
        chapter_file_for_this_run = args.chapters
        if chapter_file_for_this_run and len(files_to_process) > 1:
            # --- MODIFIED: Added verbose check (v8.1.0) ---
            if args.verbose:
                print("Info: --chapters flag is ignored in batch/directory mode for now.")
            chapter_file_for_this_run = None # Disable chapters for batch mode
        if chapter_file_for_this_run and not os.path.exists(chapter_file_for_this_run):
             print(f"Warning: Chapter file '{chapter_file_for_this_run}' not found. Skipping chapter embedding.")
             chapter_file_for_this_run = None

        # --- Permissions ---
        permissions_to_apply = None
        try:
            stat_info = os.stat(input_file);
            input_gid = stat_info.st_gid; input_group_name = grp.getgrgid(input_gid).gr_name
            target_gid = input_gid
            if input_group_name != 'jellyfin':
                try:
                    jellyfin_gid = grp.getgrnam('jellyfin').gr_gid
                    response = input(f"Warning: Source group is '{input_group_name}'. Change output to 'jellyfin'? [Y/n]: ").lower().strip()
                    if response in ('y', 'yes', ''): 
                        target_gid = jellyfin_gid;
                        # --- MODIFIED: Added verbose check (v8.1.0) ---
                        if args.verbose:
                            print("Info: Output group set to 'jellyfin'.")
                except KeyError: 
                    # --- MODIFIED: Added verbose check (v8.1.0) ---
                    if args.verbose:
                        print("Info: 'jellyfin' group not found. Preserving original.")
                except (KeyboardInterrupt, EOFError): print("\nCancelled.");
                sys.exit(1)
            permissions_to_apply = {'uid': stat_info.st_uid, 'gid': target_gid, 'mode': stat_info.st_mode}
        except (OSError, KeyError) as e: print(f"Warning: Could not read source permissions. Reason: {e}", file=sys.stderr)

        # --- MODIFIED: Corrected indentation (v8.0.5) ---
        if args.skip_hevc and is_hevc(input_file):
            print("Already HEVC. Skipping.")
            continue
        # --- END MODIFIED ---

        # --- Output Filename Generation ---
        is_remux_op = args.remux and not args.hvec # <--- Moved this line up
        
        def generate_output_filename(base, is_remux, has_chapters, is_normalized):
            sanitized = re.sub(r'[\(\)\[\]]', '', base).replace(' ', '.').replace('_', '.') # Cleaner regex
            suffix = ".REMUX" if is_remux else ".CONV"
            chapter_suffix = ".CHAPTERS" if has_chapters else ""
            norm_suffix = ".NORM" if is_normalized else "" # <--- Use our new flag
            # Ensure suffix isn't duplicated, handle case where base already ends with it
            base_no_suffix = sanitized.replace(suffix, '') if sanitized.endswith(suffix) else sanitized
            return f"{base_no_suffix}{suffix}{norm_suffix}{chapter_suffix}.mkv"

        if args.output and len(files_to_process) == 1: output_file = args.output
        else:
            base, _ = os.path.splitext(os.path.basename(input_file));
            # Check for suffixes
            has_chapters_flag = chapter_file_for_this_run is not None
            has_normalized_flag = is_normalize_enabled # <--- Use our new flag
            new_filename = generate_output_filename(base, is_remux_op, has_chapters_flag, has_normalized_flag)
            
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input if os.path.isdir(args.input) else os.path.dirname(args.input))
                output_dir = os.path.join(args.out_dir, relative_path);
                os.makedirs(output_dir, exist_ok=True)
                output_file = os.path.join(output_dir, new_filename)
            else: output_file = os.path.join(os.path.dirname(input_file), new_filename)
        
        # Prevent source overwrite
        if os.path.abspath(output_file) == os.path.abspath(input_file):
            base, ext = os.path.splitext(output_file);
            output_file = f"{base}.COPY{ext}"
            # --- MODIFIED: Added verbose check (v8.1.0) ---
            if args.verbose:
                print(f"Info: Output name identical to input. Using '{os.path.basename(output_file)}'")
                    
        # Overwrite check
        if os.path.exists(output_file) and not args.dry_run:
            try:
                if input(f"Output '{os.path.basename(output_file)}' exists. Overwrite? [y/N]: ").lower().strip() != 'y': 
                    print("Skipping.")
                    continue
            except KeyboardInterrupt: print("\nCancelled.");
            sys.exit(1)
        
        # --- FFmpeg Command Construction ---
        total_frames = get_total_frames(input_file) if not (is_remux_op or args.quiet or args.dry_run) else None
        
        ffmpeg_cmd = ['ffmpeg', '-y', '-nostdin']
        
        # Progress/Verbosity
        use_progress_bar = total_frames is not None and not (is_remux_op or args.quiet or args.dry_run)
        if use_progress_bar:
            if sys.platform != "win32": ffmpeg_cmd = ['stdbuf', '-o0'] + ffmpeg_cmd
            ffmpeg_cmd.extend(['-progress', '-', '-nostats'])
        elif args.quiet: ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        else: ffmpeg_cmd.extend(['-v', 'error', '-stats'])
        
        # --- HWACCEL & .avi FIX (v7.7) ---
        is_avi = input_file.lower().endswith('.avi')
        is_transcode = not is_remux_op
        
        if is_avi:
            # .avi files almost always need this to fix broken timestamps,
            # for both remuxing and transcoding.
            ffmpeg_cmd.extend(['-fflags', '+genpts'])

        if is_transcode and not is_avi:
            # Use hwaccel decode ONLY for non-avi transcodes
            ffmpeg_cmd.extend(['-hwaccel', 'vaapi', '-hwaccel_output_format', 'vaapi'])
        # --- END FIX ---
            
        # --- MODIFIED: Auto-detect sidecar subtitles (v8.0.9) ---
        
        # 1. Gather all external subtitles (manual + auto-detected)
        external_sub_files: List[str] = []
        
        # Add manually specified subs first
        if args.subs:
            for sub_file in args.subs:
                if os.path.exists(sub_file):
                    external_sub_files.append(os.path.abspath(sub_file))
                else:
                    print(f"Warning: Manual subtitle file not found: {sub_file}")
        
        # Auto-detect sidecar files (only in single-file mode)
        if len(files_to_process) == 1:
            # --- MODIFIED: Use abspath to fix relative path bug (v8.1.1) ---
            abs_input_file = os.path.abspath(input_file)
            input_dir = os.path.dirname(abs_input_file)
            # --- END MODIFIED ---
            input_base = os.path.splitext(os.path.basename(input_file))[0]
            
            # --- MODIFIED: Added verbose output (v8.1.0) ---
            if args.verbose:
                print("Info: Scanning for sidecar subtitles...")
                print(f"      - In directory: {input_dir}")
                print(f"      - For base name: {input_base}")
            
            try:
                for item in os.listdir(input_dir):
                    item_path = os.path.join(input_dir, item)
                    item_base, item_ext = os.path.splitext(item)
                    
                    # Check if it's a sub file, matches the base name, and isn't already in our list
                    if item_ext.lower() in SUBTITLE_EXTENSIONS and item_base.startswith(input_base):
                        abs_item_path = os.path.abspath(item_path)
                        if abs_item_path not in external_sub_files:
                            if args.verbose:
                                print(f"Info: Found sidecar: {item}")
                            external_sub_files.append(abs_item_path)
            except OSError as e:
                print(f"Warning: Could not scan for sidecar subtitles: {e}", file=sys.stderr)
            
            if args.verbose and not external_sub_files and not args.subs:
                print("Info: No sidecar or manual subtitles found.")
            # --- END MODIFIED (v8.1.0) ---

        # 2. Add all inputs to ffmpeg command
        ffmpeg_cmd.extend(['-i', input_file]) # Main video input (index 0)
        
        subtitle_input_index = 1 # Starts at 1
        for sub_file in external_sub_files:
            ffmpeg_cmd.extend(['-i', sub_file])
        
        # --- MODIFIED: Stream Mapping (v8.1.7) ---
        if args.filter_streams and len(files_to_process) == 1:
            all_streams = get_stream_info(input_file)
            if all_streams is None: continue
            s_keep, s_rem = plan_stream_selection(all_streams)
            if not display_and_confirm_plan(s_keep, s_rem):
                print("Skipping file.")
                continue
            for stream in s_keep: ffmpeg_cmd.extend(['-map', f"0:{stream['index']}"])
            # Do not map any external subs if filtering
        
        else: 
            # Default auto-mapping logic
            if args.verbose:
                print("Info: Mapping all streams from input 0 (video, audio, subs, chapters, etc).")
                
            ffmpeg_cmd.extend(['-map', '0']) # Map ALL streams from input 0
            
            # Now map all *external* subs we just added
            if external_sub_files:
                if args.verbose:
                    print(f"Info: Mapping {len(external_sub_files)} external subtitle stream(s).")
                
                # We need to find out how many embedded subs there are to offset the metadata index
                embedded_sub_count = 0
                try:
                    all_streams = get_stream_info(input_file)
                    if all_streams:
                        # Count all non-video and non-audio streams to be safe
                        embedded_sub_count = len([s for s in all_streams if s.get('codec_type') not in ['video', 'audio']])
                except Exception:
                    pass # Fail safe, count is 0
                
                for i in range(len(external_sub_files)):
                    current_input_index = i + 1 # +1 because 0 is the video
                    ffmpeg_cmd.extend([f'-map', f'{current_input_index}']) # Map all streams from this sub file
                    
                    # Add language metadata
                    lang_code = "eng" # Default
                    base_name, _ = os.path.splitext(os.path.basename(external_sub_files[i]))
                    parts = base_name.split('.')
                    if len(parts) > 1 and len(parts[-1]) in [2, 3]: # e.g., .en.srt
                        lang_part = parts[-1]
                        if lang_part not in ['forced', 'sdh']: # common suffixes that aren't langs
                            lang_code = lang_part
                    
                    # This logic is now simpler: just map to the next sub index.
                    # ffmpeg's default mapping `-map 0` will add all embedded subs first.
                    # Our new `-map 1`, `-map 2` will add external subs after them.
                    # We just need to set metadata for the *output* streams.
                    
                    # Total output subtitle streams = embedded subs + external subs
                    # This sets metadata for the *i*-th *external* sub
                    output_sub_index = embedded_sub_count + i
                    ffmpeg_cmd.extend([f'-metadata:s:s:{output_sub_index}', f'language={lang_code}'])

        # --- END MODIFIED (v8.1.7) ---

        # --- Codec Logic (Refactored for v7.2) ---
        audio_normalized = False # <--- MOVED: Define here for later use

        # 1. VIDEO LOGIC
        if is_remux_op:
            print("Mode: Lossless Video Remux");
            ffmpeg_cmd.extend(['-c:v', 'copy'])
        else:
            print("\nMode: VAAPI Video Transcode")
            
            # --- .avi HWACCEL FIX (v7.7) ---
            if is_transcode and is_avi:
                # Add the manual hwupload filter (goes AFTER -i)
                ffmpeg_cmd.extend(['-vf', 'format=nv12,hwupload'])
            # --- END FIX ---
                
            ffmpeg_cmd.extend(['-c:v', 'hevc_vaapi', '-preset', args.preset, '-global_quality', str(args.quality)])

        # --- MODIFIED: Reworked Audio Logic (v8.1.6) ---
        
        # 2. AUDIO LOGIC
        if is_normalize_enabled:
            if is_remux_op:
                print("Info: Normalizing audio while remuxing video.")
            
            abs_input_file = os.path.abspath(input_file)
            if abs_input_file in loudness_db:
                analysis_data = loudness_db[abs_input_file]
                if args.verbose:
                    print("Info: Using pre-analyzed loudness data from log.")
            else:
                if isinstance(args.normalize, str) and args.verbose:
                    print(f"Info: File not found in log, running live analysis...")
                print("Running audio normalization analysis (Pass 1)...")
                analysis_data = run_loudnorm_analysis(input_file) # <-- NOW USES FAST ebur128
                if analysis_data:
                    print("Analysis complete.")
        
        if is_normalize_enabled and analysis_data:
            # Normalization is ON and SUCCESSFUL
            try:
                measured_i = analysis_data['i']
                measured_tp = analysis_data['tp']
                measured_lra = analysis_data['lra']
                measured_thresh = analysis_data['thresh']
                
                # Print audio stats
                print("Info: Audio analysis found:")
                print(f"  - Input Loudness: {measured_i:.2f} LUFS")
                print(f"  - Input True Peak: {measured_tp:.2f} dBTP")
                
                filter_string = f"loudnorm=I=-23:LRA=7:tp=-2:measured_I={measured_i}:measured_tp={measured_tp}:measured_LRA={measured_lra}:measured_thresh={measured_thresh}"
                
                # Set ALL other audio streams to copy first
                ffmpeg_cmd.extend(['-c:a', 'copy'])
                # NOW, override stream 0 to re-encode and apply the filter
                ffmpeg_cmd.extend(['-c:a:0', 'aac', '-q:a:0', '4', '-af:a:0', filter_string])
                
                print("Info: Audio stream 0 will be normalized (EBU R128). Other audio streams copied.")
                audio_normalized = True # Mark as complete
            except KeyError:
                print("Warning: Audio analysis data was incomplete. Falling back to copy.", file=sys.stderr)
                audio_normalized = False # Mark as failed
        
        if not audio_normalized:
            # Normalization is OFF, or it FAILED
            if args.acodec:
                ffmpeg_cmd.extend(['-c:a', args.acodec])
                if args.abitrate: # Only add bitrate if acodec is also specified
                    ffmpeg_cmd.extend(['-b:a', args.abitrate])
            else:
                # Default case: no normalization, no acodec = copy all
                ffmpeg_cmd.extend(['-c:a', 'copy'])
                if not is_normalize_enabled: # Only print this if normalization was never on
                    if args.verbose:
                        print("Info: Copying all audio streams.")
            
            if is_normalize_enabled and not analysis_data:
                 print("Warning: Audio normalization analysis failed. Falling back to default audio settings.", file=sys.stderr)
        # --- END MODFED (v8.1.6) ---

        # 3. SUBTITLE, CHAPTER, and OTHER STREAM LOGIC
        if is_remux_op:
            # For remux, copy subtitles, chapters, attachments, etc. as-is
            if args.verbose:
                print("Info: Copying all subtitle, chapter, and attachment streams.")
            ffmpeg_cmd.extend(['-c:s', 'copy', '-c:c', 'copy', '-c:t', 'copy'])
        else:
            # For transcode, convert text subs to srt, copy chapters/attachments
            if args.verbose:
                print("Info: Converting text subtitles to SRT, copying chapters/attachments.")
            ffmpeg_cmd.extend(['-c:s', 'srt', '-c:c', 'copy', '-c:t', 'copy'])
        # --- END MODIFIED (v8.1.7) ---
        
        # --- END Codec Logic ---

        ffmpeg_cmd.append(output_file) # Add output file path
        
        # --- Execute ---
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
            if chapter_file_for_this_run:
                 mkvpropedit_cmd = ['mkvpropedit', output_file, '--chapters', chapter_file_for_this_run]
                 print("\nMKVPropEdit command (Dry Run):")
                 print(' '.join(f'"{a}"' if ' ' in a else a for a in mkvpropedit_cmd))
        else:
            run_ffmpeg_command(
                ffmpeg_cmd,
                input_file,
                args.delete,
                audio_normalized=audio_normalized, # <--- MODIFIED
                total_frames=total_frames,
                permissions=permissions_to_apply,
                chapter_file_to_embed=chapter_file_for_this_run,
                verbose=args.verbose # <-- MODIFIED: Pass verbose flag
            )

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()