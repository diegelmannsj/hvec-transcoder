#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete

# --- Version History ---
__version__ = "3.4"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v3.4: In batch mode, output files are now automatically renamed with a .CONV
      suffix before the extension to distinguish them from source files.
v3.3: Modified script to always print the current version number on execution
      as the first line of output, regardless of other flags.
v3.2: Fixed a crash when transcoding files with bitmap subtitles (e.g., PGS).
      The script now copies subtitle streams (-c:s copy) instead of trying
      to force a conversion to SRT format (-c:s srt).
v3.1: Added -H/--hvec flag to explicitly force the output to be a transcoded
      HEVC/H.265 file. This flag will override --remux if both are used.
v3.0: Major feature release. Added batch processing, smarter transcoding,
      and advanced audio control.
"""

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')

# --- Helper Functions ---
# ... (all helper functions are unchanged) ...
def find_video_files(input_path, recursive):
    """Finds all video files in a given path."""
    video_files = []
    if recursive:
        for root, _, files in os.walk(input_path):
            for file in files:
                if file.lower().endswith(VIDEO_EXTENSIONS):
                    video_files.append(os.path.join(root, file))
    else:
        for file in os.listdir(input_path):
            if file.lower().endswith(VIDEO_EXTENSIONS):
                video_files.append(os.path.join(input_path, file))
    return video_files

def is_hevc(file_path):
    """Checks if the video codec of a file is HEVC."""
    if not os.path.exists(file_path):
        return False
    ffprobe_cmd = [
        'ffprobe', '-v', 'error', '-select_streams', 'v:0',
        '-show_entries', 'stream=codec_name', '-of',
        'default=noprint_wrappers=1:nokey=1', file_path
    ]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return 'hevc' in result.stdout.lower()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def print_ffmpeg_command(cmd):
    """Prints the command in a copy-pasteable format."""
    print("\nExecuting FFmpeg command (Dry Run):")
    cmd_str = ' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd)
    print(cmd_str)

def run_ffmpeg_command(cmd):
    """Prints and executes the FFmpeg command."""
    print("\nExecuting FFmpeg command:")
    cmd_str = ' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd)
    print(cmd_str)
    print("\n------------------------- FFmpeg Output -------------------------")
    try:
        process = subprocess.run(cmd, check=True)
        print("-----------------------------------------------------------------")
        print(f"\nSuccessfully created '{cmd[-1]}'.")
    except FileNotFoundError:
        print("\nError: 'ffmpeg' not found. Is it installed and in your PATH?", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print("-----------------------------------------------------------------")
        print(f"\nError: FFmpeg failed with exit code {e.returncode}.", file=sys.stderr)
        sys.exit(1)

# --- Main Logic ---

def main():
    """Parses arguments and performs media operations."""
    print(f"hvec v{__version__}")

    if '-v' in sys.argv or '--version' in sys.argv:
        print(VERSION_HISTORY)
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="A tool to transcode or remux video files using Intel QSV.",
        formatter_class=argparse.RawTextHelpFormatter,
        epilog="""
Examples:
  # Transcode a single file with default settings
  ,hvec -i movie.mp4

  # Transcode all videos in a folder, adding .CONV to each new filename
  ,hvec -i /path/to/videos/
"""
    )
    # ... (all arguments are unchanged) ...
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    parser.add_argument("-o", "--output", help="Output MKV file. Only used for single file input.")
    parser.add_argument("--out-dir", help="Output directory for batch processing. Preserves source folder structure.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process files in subdirectories when -i is a directory.")
    parser.add_argument("-s", "--subs", help="(Optional) External subtitle file to embed (single file mode only).")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force output to be HEVC/H.265. Overrides --remux.")
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set QSV quality for video (1-51, lower is better). Default: 24.")
    parser.add_argument("-p", "--preset", type=str, default='medium',
                        choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'],
                        help="Set QSV encoding preset. Slower presets offer better compression. Default: medium.")
    parser.add_argument("--acodec", help="Re-encode audio to a specific codec (e.g., aac, ac3). Default: copy.")
    parser.add_argument("--abitrate", help="Set audio bitrate when re-encoding (e.g., 192k, 384k).")
    parser.add_argument("--skip-hevc", action="store_true", help="In batch mode, skip transcoding files that are already H.265/HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print the FFmpeg commands without executing them.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux instead of transcoding.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress most FFmpeg output. Overrides --less-noise.")
    parser.add_argument("--less-noise", action="store_true", help="Show progress updates only every 30 seconds.")
    parser.add_argument("-v", "--version", action="store_true", help="Show the version history and exit.")

    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    files_to_process = []
    if not os.path.exists(args.input):
        print(f"Error: Input path not found: '{args.input}'", file=sys.stderr)
        sys.exit(1)

    if os.path.isdir(args.input):
        print(f"\nInput is a directory. Scanning for video files...")
        files_to_process = find_video_files(args.input, args.recursive)
        print(f"Found {len(files_to_process)} video files to process.")
    else:
        files_to_process.append(args.input)

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")

        if args.skip_hevc and is_hevc(input_file):
            print("Video is already HEVC. Skipping.")
            continue

        # --- Determine Output Path ---
        output_file = ""
        if len(files_to_process) > 1: # Batch mode
            base_name, _ = os.path.splitext(os.path.basename(input_file))
            # --- THE CHANGE IS HERE ---
            new_filename = base_name + ".CONV.mkv"
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input)
                output_dir = os.path.join(args.out_dir, relative_path)
                if not os.path.exists(output_dir):
                    os.makedirs(output_dir)
                output_file = os.path.join(output_dir, new_filename)
            else:
                output_file = os.path.join(os.path.dirname(input_file), new_filename)
        else: # Single file mode
            if args.output:
                output_file = args.output
            else:
                base_name, _ = os.path.splitext(input_file)
                output_file = base_name + ".mkv"
        
        # ... (rest of the script is unchanged) ...
        ffmpeg_cmd = ['ffmpeg']
        if args.quiet:
            ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        elif args.less_noise:
            ffmpeg_cmd.extend(['-stats_period', '30'])
        ffmpeg_cmd.extend(['-hwaccel', 'qsv', '-i', input_file])
        if args.subs:
            if len(files_to_process) > 1:
                print("Warning: External subtitles (--subs) are only supported for single file processing. Ignoring.")
            else:
                if not os.path.exists(args.subs):
                    print(f"Error: Subtitle file not found: '{args.subs}'", file=sys.stderr)
                    continue
                ffmpeg_cmd.extend(['-i', args.subs])
        if args.subs and len(files_to_process) == 1:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '1:s:0'])
        else:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '0:s?'])
        if args.remux and not args.hvec:
            print("Mode: Lossless Remux")
            ffmpeg_cmd.extend(['-c', 'copy'])
        else:
            if args.hvec:
                print("\nMode: QSV Transcode (Forced by -H/--hvec flag)")
            else:
                print("\nMode: QSV Transcode")
            ffmpeg_cmd.extend(['-c:v', 'hevc_qsv', '-preset', args.preset, '-global_quality', str(args.quality)])
            if args.acodec:
                print(f"Re-encoding audio to {args.acodec.upper()}")
                ffmpeg_cmd.extend(['-c:a', args.acodec])
                if args.abitrate:
                    ffmpeg_cmd.extend(['-b:a', args.abitrate])
            else:
                ffmpeg_cmd.extend(['-c:a', 'copy'])
            ffmpeg_cmd.extend(['-c:s', 'copy'])
        ffmpeg_cmd.append(output_file)
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
        else:
            run_ffmpeg_command(ffmpeg_cmd)

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()