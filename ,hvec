#!/usr/bin/env python3

import argparse
import subprocess
import sys
import os
import json
import math
import argcomplete
import re
from tqdm import tqdm

# --- Version History ---
__version__ = "5.11"

VERSION_HISTORY = f"""
,hvec Transcoder v{__version__}
---------------------------------
v5.11: CRITICAL FIX: Added a manual overwrite prompt within the script. This
       solves an issue where ffmpeg's own overwrite prompt was hidden,
       causing the process to hang and the progress bar to stall at 0%.
       The script now adds '-y' to the ffmpeg command to prevent it from
       prompting, as the script now handles this interaction itself.
v5.10: Reworked progress bar to use ffmpeg's '-progress' flag to fix stalls.
v5.9: Added a tqdm progress bar with ETA for FFmpeg transcode operations.
v5.8: Added a handler for Ctrl+C (KeyboardInterrupt) to exit gracefully.
v5.7: CRITICAL FIX: Replaced ffmpeg -n flag with a robust 3-point check.
v5.6: Reworked filename suffix logic to handle all cases correctly.
v5.5: Prevent adding .REMUX suffix to filenames that already contain .CONV.
v5.4: Filename sanitization now also replaces underscores (_) with periods.
v5.3: Use .REMUX.mkv suffix for --remux operations instead of .CONV.mkv.
v5.2: Modified --subs to accept multiple files and set language metadata.
v5.1: Changed default output name for single files to include the .CONV suffix.
v5.0: Added interactive Stream Filtering mode (-k, --filter-streams).
"""

# --- Constants ---
VIDEO_EXTENSIONS = ('.mkv', '.mp4', '.avi', '.mov', '.ts', '.m2ts', '.wmv', '.flv', '.webm')

# --- Helper Functions (Unchanged) ---
def get_video_duration(file_path):
    ffprobe_cmd = ['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', file_path]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return float(result.stdout.strip())
    except (FileNotFoundError, subprocess.CalledProcessError, ValueError):
        print(f"Warning: Could not get video duration for '{file_path}'. Progress bar disabled.", file=sys.stderr)
        return None

def get_stream_info(file_path):
    ffprobe_cmd = ['ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_streams', file_path]
    try:
        result = subprocess.run(ffprobe_cmd, check=True, capture_output=True, text=True)
        return json.loads(result.stdout).get('streams', [])
    except (FileNotFoundError, subprocess.CalledProcessError, json.JSONDecodeError):
        print(f"Error: Could not get stream information from '{file_path}'.", file=sys.stderr)
        return None

def plan_stream_selection(streams):
    streams_to_keep, streams_to_remove = [], []
    for s in streams:
        keep = False
        stype = s.get('codec_type')
        tags = s.get('tags', {})
        lang = tags.get('language', 'und').lower()
        title = tags.get('title', '').lower()
        if stype == 'video' or (stype == 'audio' and (lang == 'eng' or 'commentary' in title or 'director' in title)) or (stype == 'subtitle' and lang == 'eng'):
            keep = True
        if keep: streams_to_keep.append(s)
        else: streams_to_remove.append(s)
    return streams_to_keep, streams_to_remove

def display_and_confirm_plan(streams_to_keep, streams_to_remove):
    print("\n--- Stream Selection Plan ---")
    print("The following streams will be KEPT:")
    for s in streams_to_keep or [None]: print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})" if s else "  - None")
    print("\nThe following streams will be REMOVED:")
    for s in streams_to_remove or [None]: print(f"  - Stream #{s['index']} ({s.get('codec_type', 'N/A').capitalize()})" if s else "  - None")
    print("-----------------------------")
    try:
        return input("Proceed with this selection? [y/N]: ").lower().strip() == 'y'
    except KeyboardInterrupt:
        print("\nOperation cancelled by user.")
        return False

def format_bytes(size_bytes):
    if size_bytes is None or size_bytes == 0: return "0B"
    size_name = ("B", "KB", "MB", "GB", "TB")
    i = int(math.floor(math.log(size_bytes, 1024)))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return f"{s} {size_name[i]}"

def print_size_summary(original_bytes, new_bytes):
    if original_bytes is None or new_bytes is None: return
    print("\n--- File Size Summary ---")
    print(f"Original Size: {format_bytes(original_bytes)}")
    print(f"New Size     : {format_bytes(new_bytes)}")
    if original_bytes > 0:
        diff = original_bytes - new_bytes
        perc = (diff / original_bytes) * 100
        if diff > 0: print(f"Space Saved  : {format_bytes(diff)} ({perc:.2f}% reduction)")
        else: print(f"Size Increase: {format_bytes(abs(diff))} ({abs(perc):.2f}% increase)")
    print("-------------------------")

def find_video_files(input_path, recursive):
    video_files = []
    if recursive:
        for root, _, files in os.walk(input_path):
            video_files.extend([os.path.join(root, f) for f in files if f.lower().endswith(VIDEO_EXTENSIONS)])
    else:
        video_files.extend([os.path.join(input_path, f) for f in os.listdir(input_path) if f.lower().endswith(VIDEO_EXTENSIONS)])
    return video_files

def is_hevc(file_path):
    if not os.path.exists(file_path): return False
    cmd = ['ffprobe', '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=codec_name', '-of', 'default=noprint_wrappers=1:nokey=1', file_path]
    try:
        result = subprocess.run(cmd, check=True, capture_output=True, text=True)
        return 'hevc' in result.stdout.lower()
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False

def print_ffmpeg_command(cmd):
    print("\nExecuting FFmpeg command (Dry Run):")
    print(' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd))

def run_ffmpeg_command(cmd, source_file, delete_source, is_remux=False, is_quiet=False):
    print("\nExecuting FFmpeg command:")
    print(' '.join(f'"{arg}"' if ' ' in arg else arg for arg in cmd))
    output_file = cmd[-1]
    original_size = os.path.getsize(source_file) if os.path.exists(source_file) else None
    
    if is_remux or is_quiet:
        print("\n(Progress bar is disabled for remux or quiet mode)")
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print(f"\nError: FFmpeg failed with exit code {e.returncode}.", file=sys.stderr)
            sys.exit(1)
    else:
        total_duration = get_video_duration(source_file)
        if not total_duration:
            try:
                subprocess.run(cmd, check=True)
            except subprocess.CalledProcessError as e:
                print(f"\nError: FFmpeg failed with exit code {e.returncode}.", file=sys.stderr)
                sys.exit(1)
        else:
            try:
                time_pattern = re.compile(r"(\d{2}):(\d{2}):(\d{2})\.(\d{2})")
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True, encoding='utf-8')
                with tqdm(total=round(total_duration), unit='s', dynamic_ncols=True, desc="Transcoding") as pbar:
                    for line in process.stdout:
                        if line.strip().startswith("out_time="):
                            time_str = line.strip().split("=")[1]
                            match = time_pattern.search(time_str)
                            if match:
                                h, m, s, ms = map(int, match.groups())
                                elapsed_seconds = h * 3600 + m * 60 + s + ms / 100
                                update_amount = max(0, round(elapsed_seconds - pbar.n))
                                pbar.update(update_amount)
                stderr_output = process.stderr.read()
                process.wait()
                if process.returncode != 0:
                     print(f"\n--- FFmpeg Error Output ---\n{stderr_output}\n---------------------------")
                     print(f"\nError: FFmpeg failed with exit code {process.returncode}.", file=sys.stderr)
                     sys.exit(1)
            except (FileNotFoundError, KeyboardInterrupt) as e:
                print(f"\nOperation cancelled by user." if isinstance(e, KeyboardInterrupt) else "\nError: 'ffmpeg' or 'ffprobe' not found.", file=sys.stderr)
                if 'process' in locals(): process.terminate()
                sys.exit(1)

    # 3-Point Safety Check
    if not os.path.exists(output_file):
        print(f"\nError: Output file '{output_file}' was not created.", file=sys.stderr)
        sys.exit(1)
    try:
        subprocess.run(['ffprobe', '-v', 'error', output_file], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print(f"\nError: Output file '{output_file}' appears to be invalid.", file=sys.stderr)
        sys.exit(1)
    
    print(f"\nSuccessfully created and verified '{output_file}'.")
    new_size = os.path.getsize(output_file) if os.path.exists(output_file) else None
    print_size_summary(original_size, new_size)
    
    if delete_source:
        print(f"\nInfo: --delete flag is set. Deleting source file...")
        try:
            os.remove(source_file)
            print(f"Successfully deleted: {source_file}")
        except OSError as e:
            print(f"\nError: Could not delete source file '{source_file}'. Reason: {e}", file=sys.stderr)

# --- Main Logic ---
def main():
    if '-v' in sys.argv or '--version' in sys.argv:
        print(VERSION_HISTORY)
        sys.exit(0)
    parser = argparse.ArgumentParser(description="A tool to transcode or remux video files using Intel QSV.", formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("-i", "--input", required=True, help="Input video file or directory.")
    # Add other arguments... (rest of parser setup is unchanged)
    parser.add_argument("-o", "--output", help="Output MKV file. If specified, name sanitization is skipped.")
    parser.add_argument("-k", "--filter-streams", action="store_true", help="Interactively filter audio/subtitle streams.")
    parser.add_argument("-D", "--delete", action="store_true", help="Delete the original input file after a successful transcode.")
    parser.add_argument("--out-dir", help="Output directory for batch processing.")
    parser.add_argument("-R", "--recursive", action="store_true", help="Process files in subdirectories.")
    parser.add_argument("-s", "--subs", nargs='+', help="One or more external subtitle files to embed.")
    parser.add_argument("-H", "--hvec", action="store_true", help="Force output to be HEVC/H.265. Overrides --remux.")
    parser.add_argument("-Q", "--quality", type=int, default=24, help="Set QSV quality for video (1-51, lower is better). Default: 24.")
    parser.add_argument("-p", "--preset", type=str, default='medium', choices=['veryfast', 'faster', 'fast', 'medium', 'slow', 'slower', 'veryslow'], help="Set QSV encoding preset. Default: medium.")
    parser.add_argument("--acodec", help="Re-encode audio to a specific codec (e.g., aac, ac3).")
    parser.add_argument("--abitrate", help="Set audio bitrate when re-encoding (e.g., 192k).")
    parser.add_argument("--skip-hevc", action="store_true", help="In batch mode, skip files that are already HEVC.")
    parser.add_argument("--dry-run", action="store_true", help="Print FFmpeg commands without executing them.")
    parser.add_argument("-r", "--remux", action="store_true", help="Perform a lossless remux instead of transcoding.")
    parser.add_argument("-q", "--quiet", action="store_true", help="Suppress FFmpeg's console output. Disables progress bar.")
    parser.add_argument("--less-noise", action="store_true", help="Show progress updates only every 30 seconds.")
    parser.add_argument("-v", "--version", action="store_true", help="Show the version history and exit.")
    
    argcomplete.autocomplete(parser)
    args = parser.parse_args()
    print(f",hvec v{__version__}")

    files_to_process = find_video_files(args.input, args.recursive) if os.path.isdir(args.input) else [args.input]
    if not os.path.exists(args.input):
        print(f"Error: Input path not found: '{args.input}'", file=sys.stderr); sys.exit(1)

    for i, input_file in enumerate(files_to_process, 1):
        print(f"\n--- Processing file {i}/{len(files_to_process)}: {os.path.basename(input_file)} ---")
        if args.skip_hevc and is_hevc(input_file):
            print("Video is already HEVC. Skipping."); continue

        def generate_output_filename(base, is_remux):
            sanitized = base.replace('(', '').replace(')', '').replace(' ', '.').replace('_', '.')
            suffix = ".REMUX" if is_remux else ".CONV"
            return f"{sanitized}{suffix}.mkv" if not sanitized.endswith(suffix) else f"{sanitized}.mkv"

        if args.output and len(files_to_process) == 1:
            output_file = args.output
        else:
            base, _ = os.path.splitext(os.path.basename(input_file))
            new_filename = generate_output_filename(base, args.remux)
            if args.out_dir:
                relative_path = os.path.relpath(os.path.dirname(input_file), args.input if os.path.isdir(args.input) else os.path.dirname(args.input))
                output_dir = os.path.join(args.out_dir, relative_path)
                os.makedirs(output_dir, exist_ok=True)
                output_file = os.path.join(output_dir, new_filename)
            else:
                output_file = os.path.join(os.path.dirname(input_file), new_filename)
        
        # --- MODIFICATION START ---
        # Add an explicit overwrite check before running ffmpeg.
        if os.path.exists(output_file) and not args.dry_run:
            try:
                choice = input(f"Output file '{os.path.basename(output_file)}' already exists. Overwrite? [y/N]: ").lower().strip()
                if choice != 'y':
                    print("Skipping file.")
                    continue
            except KeyboardInterrupt:
                print("\nOperation cancelled by user.")
                sys.exit(1)
        # --- MODIFICATION END ---
        
        # --- COMMAND BUILDING LOGIC ---
        # --- MODIFICATION START ---
        # Always add -y now since the script handles the overwrite prompt.
        ffmpeg_cmd = ['ffmpeg', '-y']
        # --- MODIFICATION END ---
        
        if args.quiet:
            ffmpeg_cmd.extend(['-loglevel', 'error', '-hide_banner'])
        else:
            ffmpeg_cmd.extend(['-progress', '-', '-nostats'])
        
        ffmpeg_cmd.extend(['-hwaccel', 'qsv', '-i', input_file])

        # Stream mapping logic (unchanged)
        if args.filter_streams:
            all_streams = get_stream_info(input_file)
            if all_streams is None: continue 
            streams_to_keep, _ = plan_stream_selection(all_streams)
            if not display_and_confirm_plan(streams_to_keep, _): print("Skipping file."); continue
            for stream in streams_to_keep: ffmpeg_cmd.extend(['-map', f"0:{stream['index']}"])
        elif args.subs and len(files_to_process) == 1:
            for sub_file in args.subs:
                if os.path.exists(sub_file): ffmpeg_cmd.extend(['-i', sub_file])
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?'])
            for j in range(len(args.subs)):
                ffmpeg_cmd.extend(['-map', f'{j+1}:s:0', f'-metadata:s:s:{j}', 'language=eng'])
        else:
            ffmpeg_cmd.extend(['-map', '0:v:0', '-map', '0:a?', '-map', '0:s?'])

        # Codec logic (unchanged)
        is_remux_op = args.remux and not args.hvec
        if is_remux_op:
            print("Mode: Lossless Remux"); ffmpeg_cmd.extend(['-c', 'copy'])
            if args.subs: ffmpeg_cmd.extend(['-c:s', 'srt'])
        else:
            print("\nMode: QSV Transcode"); ffmpeg_cmd.extend(['-c:v', 'hevc_qsv', '-preset', args.preset, '-global_quality', str(args.quality)])
            ffmpeg_cmd.extend(['-c:a', args.acodec] if args.acodec else ['-c:a', 'copy'])
            if args.acodec and args.abitrate: ffmpeg_cmd.extend(['-b:a', args.abitrate])
            ffmpeg_cmd.extend(['-c:s', 'srt'] if args.subs else ['-c:s', 'copy'])
            
        ffmpeg_cmd.append(output_file)
        
        if args.dry_run:
            print_ffmpeg_command(ffmpeg_cmd)
        else:
            run_ffmpeg_command(ffmpeg_cmd, input_file, args.delete, is_remux=is_remux_op, is_quiet=args.quiet)

    print("\n--- All tasks complete. ---")

if __name__ == "__main__":
    main()